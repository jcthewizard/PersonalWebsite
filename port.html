<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Josh Chou - Interactive Portfolio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        #ui-overlay h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #ui-overlay p {
            margin: 8px 0;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.4;
        }

        #dialogue-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.65);
            color: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 1000;
        }

        #dialogue-box h3 {
            margin: 0 0 15px 0;
            color: rgba(255, 255, 255, 1);
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        #dialogue-content {
            margin: 15px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
            color: rgba(255, 255, 255, 1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .dialogue-option {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin: 10px 0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        .dialogue-option:hover {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 1);
            transform: translateX(5px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        }

        #custom-question-container {
            margin-top: 15px;
            padding-top: 0;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        #custom-question-input {
            width: 100%;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        #custom-question-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        #custom-question-submit {
            background: rgba(0, 0, 0, 0.4);
            color: rgba(255, 255, 255, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 12px 24px;
            margin-top: 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        #custom-question-submit:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        #custom-question-submit:disabled {
            background: rgba(0, 0, 0, 0.2);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        /* Painting Tooltip Styles */
        .painting-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 2000;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .painting-tooltip h4 {
            display: none;
        }

        .painting-tooltip p {
            margin: 0;
            color: #333;
            line-height: 1.4;
            font-weight: 500;
        }

        /* Speaker Tooltip Styles */
        .speaker-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 2000;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .speaker-tooltip h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
            font-weight: bold;
        }

        .speaker-tooltip p {
            margin: 0;
            color: #333;
            line-height: 1.4;
        }

        /* Computer Terminal Popup Styles */
        .computer-terminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            height: 70%;
            background: #1a1a1a;
            border: 3px solid #333;
            border-radius: 8px;
            display: none;
            z-index: 3000;
            font-family: 'Courier New', monospace;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
        }

        .terminal-header {
            background: #333;
            padding: 10px 15px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            color: #00ff00;
            font-weight: bold;
            font-size: 14px;
        }

        .terminal-close {
            background: #ff4444;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .terminal-close:hover {
            background: #ff6666;
        }

        .terminal-content {
            padding: 20px;
            height: calc(100% - 60px);
            overflow-y: auto;
            color: #00ff00;
            font-size: 14px;
            line-height: 1.6;
            background: #1a1a1a;
        }

        .terminal-content::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: #333;
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .project-item {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #222;
        }

        .project-title {
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .project-tech {
            color: #ffff00;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .project-description {
            color: #00ff00;
            margin-bottom: 10px;
        }

        .project-link {
            color: #ff00ff;
            text-decoration: underline;
            cursor: pointer;
        }

        .project-link:hover {
            color: #ff66ff;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(65, 105, 225, 0.3);
            border-radius: 50%;
            border-top-color: #4169e1;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }

        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }

        .floating-text {
            position: absolute;
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        /* Contact Tab Styles */
        #contact-tab {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        #contact-tab:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 16px 56px rgba(0, 0, 0, 0.25), 0 6px 20px rgba(0, 0, 0, 0.15);
            color: #ffffff;
        }

        #contact-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        #contact-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 24px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2), 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #contact-content h2 {
            margin: 0 0 20px 0;
            color: rgba(255, 255, 255, 0.95);
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #contact-content p {
            margin: 15px 0;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .contact-button {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            margin: 10px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .contact-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #close-contact {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 18px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #close-contact:hover {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        /* Social Icons Styles */
        #social-icons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .social-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: white;
            font-size: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .social-icon:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 16px 56px rgba(0, 0, 0, 0.25), 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .social-icon.github {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.github:hover {
            background: rgba(36, 41, 46, 0.8);
        }

        .social-icon.linkedin {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.linkedin:hover {
            background: rgba(0, 119, 181, 0.8);
        }

        .social-icon.twitter {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.twitter:hover {
            background: rgba(29, 161, 242, 0.8);
        }

        .social-icon.email {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.email:hover {
            background: rgba(234, 67, 53, 0.8);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <h2 id="title">Josh Chou's Den</h2>
        <p id="move-instruction">Use WASD to move around</p>
        <p id="look-instruction">Arrow keys or mouse to look left/right</p>
        <p id="interact-instruction">Press E to interact</p>
        <p id="dance-instruction">Press SPACE to jump</p>
        <p id="close-instruction">Press ESC to close dialogs/release mouse</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Ask me anything about my background!</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Explore the room to learn more about me!</p>
    </div>

    <div id="dialogue-box">
        <h3 id="dialogue-name">Name</h3>
        <div id="dialogue-content">Content</div>
        <div id="dialogue-options"></div>
        <div id="custom-question-container">
            <p style="margin: 15px 0; font-size: 14px; opacity: 0.8; text-align: center;" id="custom-question-divider">‚îÅ‚îÅ‚îÅ Or ask your own question ‚îÅ‚îÅ‚îÅ</p>
            <input type="text" id="custom-question-input" placeholder="Ask me about my experience, skills, projects, or anything else!" maxlength="200">
            <button id="custom-question-submit">Ask Question</button>
        </div>
    </div>

    <div id="painting-tooltip" class="painting-tooltip">
        <h4 id="tooltip-title">Painting Title</h4>
        <p id="tooltip-description">Placeholder description for this painting.</p>
    </div>

    <div id="speaker-tooltip" class="speaker-tooltip">
        <h4>My current rotation (as of 7/24/25)</h4>
        <p>Daisies - Justin Bieber<br>
        Follows You - Michael Marcagi<br>
        Strawberry Swing - Coldplay<br>
        Little Bit More - Mk.gee<br>
        Saving Up - Dom Dolla</p>
    </div>

    <div id="tv-tooltip" class="speaker-tooltip">
        <h4>My Favorite Movies</h4>
        <p>How to Train Your Dragon<br>
        Real Steel<br>
        Interstellar<br>
        Tenet<br>
        Dune Pt 2</p>
    </div>

    <div id="bookshelf-tooltip" class="speaker-tooltip">
        <h4>My Favorite Books</h4>
        <p>Red Rising - Pierce Brown<br>
        Bewilderment - Richard Powers<br>
        Open - Andre Agassi<br>
        The Martian - Andy Weir<br>
        One Flew Over the Cuckoo's Nest - Ken Kesey</p>
    </div>

    <!-- Computer Terminal Popup -->
    <div id="computer-terminal" class="computer-terminal">
        <div class="terminal-header">
            <div class="terminal-title">josh@portfolio:~/projects$</div>
            <button class="terminal-close" onclick="closeComputerTerminal()">√ó</button>
        </div>
        <div class="terminal-content">
            <div style="color: #00ffff; margin-bottom: 20px;">> ls -la projects/</div>

            <div class="project-item">
                <div class="project-title">üõ°Ô∏è AWS Real-Time Fraud Detection</div>
                <div class="project-tech">Tech: TypeScript, GraphQL, AWS Lambda, Kinesis, SQS, SNS</div>
                <div class="project-description">üèÜ AWS Spark Fair Winner - High-throughput real-time fraud detection workflow processing 50M AWS activity logs daily. Reduced fraud detection time from 15-60 minutes to seconds (95% improvement). Recognized as top-performing intern across all disciplines.</div>
                <div class="project-link">Internship: June-September 2024 | Award: Amazon AWS Spark Fair</div>
            </div>

            <div class="project-item">
                <div class="project-title">üöó TestDrive.AI</div>
                <div class="project-tech">Tech: Python, OpenCV, PyTorch, YOLOV8, Intel oneAPI, Next.js, Tailwind</div>
                <div class="project-description">Full-stack computer vision application that automates driving test evaluations by analyzing dash-cam and driver-facing footage to detect violations such as lane drifting, tailgating, and smartphone usage.</div>
                <div class="project-link">Project: October 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üß† Codenames Clue Analyzer</div>
                <div class="project-tech">Tech: Python, Hugging Face API, TensorFlow, NLP</div>
                <div class="project-description">AI tool to analyze and score clues in the board game Codenames to increase win rate. Integrated semantic relationship ML model and devised accurate scoring algorithm to determine clue strength.</div>
                <div class="project-link">Project: December 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üîç Mini Google</div>
                <div class="project-tech">Tech: C, C++, Valgrind, GDB</div>
                <div class="project-description">Modular search engine with file system crawler, in-memory query processor, and persistent index storage using architecture-neutral marshalling. Implemented multithreaded web server interface supporting concurrent search requests.</div>
                <div class="project-link">Project: November 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üóÇÔ∏è Distributed Key-Value Store</div>
                <div class="project-tech">Tech: Go, RPC, Paxos Consensus Algorithm</div>
                <div class="project-description">Scalable key-value store with sharding, replication, and fault tolerance. Built custom RPC framework with exactly-once semantics. Implemented Paxos consensus for strong consistency and dynamic reconfiguration for shard migration.</div>
                <div class="project-link">Course Project: Distributed Systems</div>
            </div>

            <div class="project-item">
                <div class="project-title">‚è∞ WakeBox</div>
                <div class="project-tech">Tech: Hardware Integration, Mobile Development</div>
                <div class="project-description">üèÜ DubHacks Winner - Multifunctional alarm clock integrating physical and mental tasks for deactivation. Won first place at the largest hackathon in the PNW with 12,000+ competitors.</div>
                <div class="project-link">Award: March 2023 - DubHacks Hackathon Winner</div>
            </div>

            <div style="color: #00ffff; margin-top: 30px;">> Total projects: 6 | Awards: 2 üèÜ</div>
            <div style="color: #ffff00; margin-top: 10px;">> üéì UW Computer Science | 3.8 GPA | June 2026</div>
            <div style="color: #ffff00; margin-top: 5px;">> üöÄ Y Combinator AI Startup School Alumni | Top 2000 globally</div>
            <div style="color: #ffff00; margin-top: 5px;">> üíº Current: AWS SDE Intern | Affable BPM Founding Engineer | OdysseyHydration CTO</div>
            <div style="color: #00ff00; margin-top: 15px;">> Press 'ESC' to close terminal</div>
        </div>
    </div>

    <div id="interaction-prompt"></div>

    <!-- Contact Tab -->
    <div id="contact-tab">üìß Contact</div>

    <!-- Contact Modal -->
    <div id="contact-modal">
        <div id="contact-content">
            <button id="close-contact">&times;</button>
            <h2>Get In Touch</h2>
            <p>I'm always interested in new opportunities and collaborations. Feel free to reach out!</p>
            <a href="mailto:joshchouprofessional@outlook.com" class="contact-button">üìß Send Email</a>
            <a href="JoshChouResume.pdf" class="contact-button" download>üìÑ Download Resume</a>
            <p style="margin-top: 20px; font-size: 14px; color: #999;">
                Available for freelance work and full-time opportunities
            </p>
        </div>
    </div>

    <!-- Social Icons -->
    <div id="social-icons">
        <a href="https://github.com/jcthewizard" target="_blank" class="social-icon github" title="GitHub">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
        </a>
        <a href="https://linkedin.com/in/joshchou7" target="_blank" class="social-icon linkedin" title="LinkedIn">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
        </a>
        <a href="https://twitter.com/jcthewizard" target="_blank" class="social-icon twitter" title="Twitter">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
            </svg>
        </a>
        <a href="mailto:joshchouprofessional@outlook.com" class="social-icon email" title="Email">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M0 3v18h24V3H0zm21.518 2L12 12.713 2.482 5h19.036zM2 19V7.183l10 8.104 10-8.104V19H2z"/>
            </svg>
        </a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('Starting Josh Chou Interactive Portfolio...');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        console.log('Scene, camera, and renderer initialized');

        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);

            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);

            setTimeout(() => div.remove(), 2000);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Floor with pattern
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Add floor tiles pattern
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });

        for (let x = -15; x < 15; x += 2) {
            for (let z = -15; z < 15; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }

        // Walls with windows
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8f8f8,  // Much lighter gray color
            roughness: 0.9
        });

        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });

        // Back wall with windows
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        backWall.position.set(0, 5, -15);
        backWall.receiveShadow = true;
        backWall.castShadow = false;
        scene.add(backWall);

        // Add windows to back wall - REMOVED
        // for (let x = -10; x <= 10; x += 8) {
        //     const window = new THREE.Mesh(
        //         new THREE.PlaneGeometry(3, 2.5),
        //         windowMaterial
        //     );
        //     window.position.set(x, 5, -14.9);
        //     scene.add(window);
        // }

        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        leftWall.position.set(-15, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        leftWall.castShadow = false;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        rightWall.position.set(15, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        rightWall.castShadow = false;
        scene.add(rightWall);

        // Front wall
        const frontWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        frontWall.position.set(0, 5, 15);
        frontWall.rotation.y = Math.PI;
        frontWall.receiveShadow = true;
        frontWall.castShadow = false;
        scene.add(frontWall);

        // Ceiling
        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8,
            metalness: 0.1
        });

        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            ceilingMaterial
        );
        ceiling.position.set(0, 10, 0);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.receiveShadow = true;
        ceiling.castShadow = false;
        scene.add(ceiling);

        // Office furniture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });

        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });

        // Create a single main desk for Josh
        function createMainDesk(x, z) {
            const deskGroup = new THREE.Group();

            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);

            // Metal frame
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];

            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });

            // Computer monitor (dual setup)
            const monitorBase1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase1.position.set(-0.5, 0.82, 0);
            deskGroup.add(monitorBase1);

            const monitorBase2 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase2.position.set(0.5, 0.82, 0);
            deskGroup.add(monitorBase2);

            const monitorStand1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand1.position.set(-0.5, 0.95, 0);
            deskGroup.add(monitorStand1);

            const monitorStand2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand2.position.set(0.5, 0.95, 0);
            deskGroup.add(monitorStand2);

            const monitorScreen1 = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen1.position.set(-0.5, 1.3, 0);
            deskGroup.add(monitorScreen1);

            const monitorScreen2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen2.position.set(0.5, 1.3, 0);
            deskGroup.add(monitorScreen2);

            // Keyboard
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);

            // Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);

            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);

            // Coffee mug
            const mug = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            mug.position.set(0.8, 0.85, 0.2);
            deskGroup.add(mug);

            // Notebook
            const notebook = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.01, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x4169e1 })
            );
            notebook.position.set(-0.8, 0.81, 0.2);
            deskGroup.add(notebook);

            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }

        // Add Josh's main desk
        const mainDesk = createMainDesk(0, -5);
        scene.add(mainDesk);

        // Store desk reference globally for interaction
        window.deskObject = mainDesk;
        console.log('Desk object stored at position:', mainDesk.position);

        // Add whiteboard with "Josh Chou" written on it
        const whiteboardMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1
        });

        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            whiteboardMaterial
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = false;
        scene.add(whiteboard);
        // Gallery System - Multiple Interactive Paintings Around the Walls
        console.log('Setting up interactive gallery system...');

        const paintings = [];
        const paintingData = [
            // Back wall paintings - gallery style with equal spacing and height
            { id: 'painting1', name: 'Art Piece 1', position: [-9, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Far left
            { id: 'painting2', name: 'Art Piece 2', position: [-6, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Left
            { id: 'painting3', name: 'Art Piece 3', position: [-3, 1.7, -14.7], size: [2.4, 2.7], media: null }, // Left center (your photo - slightly wider)
            { id: 'painting4', name: 'Art Piece 4', position: [0, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Center
            { id: 'painting5', name: 'Art Piece 5', position: [3, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Right center
            { id: 'painting6', name: 'Art Piece 6', position: [6, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Right
            { id: 'painting7', name: 'Art Piece 7', position: [9, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Far right
        ];

        // Create default fallback material for empty paintings
        function createEmptyPaintingMaterial(paintingName) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(1, '#d0d0d0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Add text
            ctx.fillStyle = '#666';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Portfolio Image', 256, 200);
            ctx.font = '24px Arial';
            ctx.fillText(paintingName, 256, 240);
            ctx.fillText('üì∑', 256, 300);

            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.3,
                metalness: 0.1
            });
        }

        // Create uniform paintings
        function createPainting(data) {
            // Create frame (all frames are identical brown wood)
            const frameGeometry = new THREE.BoxGeometry(data.size[0] + 0.3, data.size[1] + 0.3, 0.25);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513, // Brown wood color for all frames
                roughness: 0.6,
                metalness: 0.1
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(...data.position.map((p, i) => i === 2 ? p - 0.15 : p));
            if (data.rotation) frame.rotation.set(...data.rotation);
            frame.castShadow = true;
            frame.receiveShadow = true;
            scene.add(frame);

            // Create painting with empty material
            const paintingGeometry = new THREE.PlaneGeometry(...data.size);
            const painting = new THREE.Mesh(paintingGeometry, createEmptyPaintingMaterial(data.name));
            painting.position.set(...data.position);
            if (data.rotation) painting.rotation.set(...data.rotation);
            painting.userData = { paintingId: data.id, frame: frame, isEmpty: true };
            painting.userData.originalMaterial = painting.material;
            scene.add(painting);

            paintings.push({ painting, frame, data, media: null });
            return painting;
        }

        // Setup all paintings uniformly
        paintingData.forEach(data => {
            createPainting(data);
        });

        console.log(`Gallery setup complete - ${paintings.length} paintings created`);

        // Hardcoded Gallery Content
        console.log('Loading predefined gallery content...');

        // Define content for each painting (you can easily modify these)
        const galleryContent = {
            'painting1': {
                type: 'image',
                title: 'Professional Photo 1',
                src: 'http://localhost:8000/IMG_0597.JPEG',
                description: 'Portfolio Image'
            },
            'painting2': {
                type: 'image',
                title: 'Professional Photo 2',
                src: 'http://localhost:8000/IMG_9022.jpeg',
                description: 'Portfolio Image'
            },
            'painting3': {
                type: 'image',
                title: 'Professional Photo 3',
                src: 'http://localhost:8000/IMG_1698%202.jpeg',
                description: 'Portfolio Image'
            },
            'painting4': {
                type: 'image',
                title: 'Professional Photo 4',
                src: 'http://localhost:8000/1722728684041.jpeg',
                description: 'Portfolio Image'
            },
            'painting5': {
                type: 'image',
                title: 'Professional Photo 5',
                src: 'http://localhost:8000/IMG_4678.JPG',
                description: 'Portfolio Image'
            },
            'painting6': {
                type: 'image',
                title: 'Professional Photo 6',
                src: 'http://localhost:8000/IMG_7509.jpeg',
                description: 'Portfolio Image'
            },
            'painting7': {
                type: 'image',
                title: 'Professional Photo 7',
                src: 'http://localhost:8000/IMG_8477.jpeg',
                description: 'Portfolio Image'
            }
        };

        // Function to create canvas-based placeholder
        function createCanvasPlaceholder(content) {
            console.log(`Creating canvas placeholder for ${content.title} with color ${content.color}`);

            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 600;
            const ctx = canvas.getContext('2d');

            // Background - make it more distinctive
            ctx.fillStyle = content.color;
            ctx.fillRect(0, 0, 800, 600);

            // Add border to make it more visible
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, 790, 590);

            // Add some pattern - large circles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(
                    100 + (i % 4) * 150,
                    150 + Math.floor(i / 4) * 200,
                    50, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Title - make it much more visible
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(content.title, 400, 200);
            ctx.fillText(content.title, 400, 200);

            // Description
            ctx.font = 'bold 40px Arial';
            ctx.strokeText(content.description, 400, 280);
            ctx.fillText(content.description, 400, 280);

            // Large icon
            ctx.font = '80px Arial';
            ctx.strokeText('üöÄ', 400, 400);
            ctx.fillText('üöÄ', 400, 400);

            // Add "CANVAS" text to make it obvious this is canvas content
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFF00';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeText('CANVAS CONTENT', 400, 500);
            ctx.fillText('CANVAS CONTENT', 400, 500);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.2,
                metalness: 0.1
            });

            console.log(`Created canvas material for ${content.title}`, material);
            return material;
        }

        // Function to load predefined content into paintings
        function loadGalleryContent() {
            console.log('Starting to load gallery content for', paintings.length, 'paintings');
            console.log('Available gallery content keys:', Object.keys(galleryContent));

            paintings.forEach((paintingObj, index) => {
                const content = galleryContent[paintingObj.data.id];
                if (!content) {
                    console.log(`No content found for ${paintingObj.data.id}`);
                    return; // Skip undefined content
                }

                console.log(`Loading ${content.title} into ${paintingObj.data.id} (index ${index})`);
                console.log(`Painting position:`, paintingObj.data.position);
                console.log(`Painting rotation:`, paintingObj.data.rotation);

                if (content.type === 'canvas') {
                    // Create canvas-based material
                    const newMaterial = createCanvasPlaceholder(content);
                    paintingObj.painting.material = newMaterial;
                    paintingObj.painting.material.needsUpdate = true;
                    console.log(`Applied canvas material to ${paintingObj.data.id}`, newMaterial);

                } else if (content.type === 'video') {
                    // Create video element
                    const video = document.createElement('video');
                    video.src = content.src;
                    video.loop = true;
                    video.muted = true;
                    video.crossOrigin = 'anonymous';
                    video.playsInline = true;
                    video.autoplay = false;

                    const videoTexture = new THREE.VideoTexture(video);
                    videoTexture.minFilter = THREE.LinearFilter;
                    videoTexture.magFilter = THREE.LinearFilter;
                    videoTexture.format = THREE.RGBFormat;

                    video.addEventListener('loadeddata', () => {
                        console.log(`Video ${content.title} loaded`);
                        paintingObj.painting.material = new THREE.MeshStandardMaterial({
                            map: videoTexture,
                            roughness: 0.1,
                            metalness: 0.1
                        });
                    });

                    video.addEventListener('canplay', () => {
                        video.play().catch(e => console.log('Video autoplay failed:', e));
                    });

                    video.load();
                    paintingObj.media = video;

                } else {
                    // Create image texture
                    const img = new Image();
                    // Remove crossOrigin for localhost to avoid CORS issues
                    // img.crossOrigin = 'anonymous';

                    console.log(`Attempting to load image: ${content.src}`);

                    img.onload = () => {
                        console.log(`Image ${content.title} loaded successfully`);
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;

                        paintingObj.painting.material = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.2,
                            metalness: 0.1
                        });
                        console.log(`Applied texture to ${paintingObj.data.id}`);
                    };

                    img.onerror = (error) => {
                        console.error(`Failed to load ${content.title} from ${content.src}:`, error);
                        console.log(`Using fallback material for ${paintingObj.data.id}`);
                        console.log(`Image error details:`, error);
                        console.log(`Attempted URL:`, content.src);
                        console.log(`Painting ID:`, paintingObj.data.id);
                        // Keep the original "Portfolio Image" material as fallback
                    };

                    // Set the source after setting up event handlers
                    img.src = content.src;
                    paintingObj.media = img;
                }

                // Brown frame for all content types
                paintingObj.frame.material.color.setHex(0x8b4513);

                // Update painting userData
                paintingObj.data.isEmpty = false;
                paintingObj.data.title = content.title;
            });

            console.log('Finished loading gallery content');
        }

        // Load all gallery content
        loadGalleryContent();

        console.log('Gallery content loaded successfully!');

        // Plant decorations
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-10, 0.2, -10);
        scene.add(plantPot);

        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-10, 0.8, -10);
        scene.add(plantLeaves);

        // Add more plants
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(10, 0.2, -10);
        scene.add(plantPot2);

        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(10, 0.8, -10);
        scene.add(plantLeaves2);

        // Additional Room Elements to Liven Things Up
        console.log('Adding substantial room elements...');

        // Large Bookshelf (left side of room) - more realistic
        function createBookshelf(x, z) {
            const bookshelfGroup = new THREE.Group();

            // Main frame materials
            const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 });
            const darkWoodMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });

            // Vertical sides
            const leftSide = new THREE.Mesh(new THREE.BoxGeometry(0.15, 6, 1), shelfMaterial);
            leftSide.position.set(-1.9, 3, 0);
            bookshelfGroup.add(leftSide);

            const rightSide = new THREE.Mesh(new THREE.BoxGeometry(0.15, 6, 1), shelfMaterial);
            rightSide.position.set(1.9, 3, 0);
            bookshelfGroup.add(rightSide);

            // Back panel
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(3.8, 5.8, 0.1), darkWoodMaterial);
            backPanel.position.set(0, 3, -0.45);
            bookshelfGroup.add(backPanel);

            // Top and bottom panels
            const topPanel = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 1), shelfMaterial);
            topPanel.position.set(0, 5.9, 0);
            bookshelfGroup.add(topPanel);

            const bottomPanel = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 1), shelfMaterial);
            bottomPanel.position.set(0, 0.1, 0);
            bookshelfGroup.add(bottomPanel);

            // Shelves (4 internal shelves)
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(3.7, 0.1, 0.9), shelfMaterial);
                shelf.position.y = (i + 1) * 1.4 + 0.2;
                bookshelfGroup.add(shelf);

                // Add books on each shelf - no randomness, consistent placement
                let currentX = -1.6; // Start at left edge
                const booksOnShelf = 7; // Fixed number of books per shelf

                for (let j = 0; j < booksOnShelf; j++) {
                    const bookColors = [0x8b0000, 0x006400, 0x4b0082, 0xff4500, 0x2f4f4f, 0x800080, 0x556b2f, 0x8b008b, 0x000080, 0x8b4513];
                    const bookWidth = 0.12; // Fixed width for all books
                    const bookHeight = 0.6 + Math.random() * 0.4; // Random height between 0.6 and 1.0
                    const baseY = (i + 1) * 1.4 + 0.2 - 1.34; // Base level for all books on this shelf

                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(bookWidth, bookHeight, 0.05),
                        new THREE.MeshStandardMaterial({ color: bookColors[j % bookColors.length] })
                    );

                    // Position books with same base but varying heights
                    book.position.set(
                        currentX + bookWidth/2,
                        baseY + bookHeight/2, // Base stays same, height varies upward
                        0.2 // Fixed depth within shelf
                    );
                    book.rotation.y = 0; // No rotation - all books perfectly aligned
                    bookshelfGroup.add(book);

                    currentX += bookWidth + 0.01; // Fixed gap between books

                    if (currentX > 1.4) break; // Stop before shelf edge
                }

            }

            bookshelfGroup.position.set(x, 0, z);
            bookshelfGroup.rotation.y = Math.PI; // Turn it around to face inward
            bookshelfGroup.castShadow = true;
            bookshelfGroup.receiveShadow = true;
            return bookshelfGroup;
        }

        const mainBookshelf = createBookshelf(-10, 13.5); // Pushed further back towards TV wall
        scene.add(mainBookshelf);

        // Store bookshelf reference globally for interaction
        window.bookshelfObject = mainBookshelf;
        console.log('Bookshelf object stored at position:', mainBookshelf.position);

        // Large TV on front wall (opposite the gallery)
        const tvGroup = new THREE.Group();

        // TV frame/bezel
        const tvFrame = new THREE.Mesh(
            new THREE.BoxGeometry(5, 3, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        tvFrame.position.y = 2;
        tvGroup.add(tvFrame);

        // TV screen
        const tvScreen = new THREE.Mesh(
            new THREE.PlaneGeometry(4.6, 2.6),
            new THREE.MeshStandardMaterial({
                color: 0x000033,
                emissive: 0x000011,
                roughness: 0.1,
                metalness: 0.1
            })
        );
        tvScreen.position.set(0, 2, 0.06);
        tvGroup.add(tvScreen);

        // TV stand/mount
        const tvStand = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.5, 0.2),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        tvStand.position.set(0, 0.5, -0.1);
        tvGroup.add(tvStand);

        tvGroup.position.set(0, 0, 14.2);
        tvGroup.castShadow = true;
        scene.add(tvGroup);

        // Store TV reference globally for interaction
        window.tvObject = tvGroup;
        console.log('TV object stored at position:', tvGroup.position);

        // Large Area Rug - moved closer to TV
        const areaRug = new THREE.Mesh(
            new THREE.PlaneGeometry(8, 6),
            new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.8,
                metalness: 0.1
            })
        );
        areaRug.rotation.x = -Math.PI / 2;
        areaRug.position.set(0, 0.02, 8);
        areaRug.receiveShadow = true;
        scene.add(areaRug);

        // Coffee Table on the rug - moved closer to TV
        const coffeeTable = new THREE.Group();

        // Table top
        const coffeeTableTop = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.1, 1.2),
            new THREE.MeshStandardMaterial({ color: 0x654321 })
        );
        coffeeTableTop.position.y = 0.4;
        coffeeTable.add(coffeeTableTop);

        // Table legs
        const legPositions = [[-1, 0.2, -0.5], [1, 0.2, -0.5], [-1, 0.2, 0.5], [1, 0.2, 0.5]];
        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x654321 })
            );
            leg.position.set(...pos);
            coffeeTable.add(leg);
        });

        // Items on coffee table
        const magazine = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.02, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        magazine.position.set(-0.5, 0.46, 0.2);
        magazine.rotation.y = 0.3;
        coffeeTable.add(magazine);

        const tvRemote = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.03, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        tvRemote.position.set(0.4, 0.46, -0.2);
        coffeeTable.add(tvRemote);

        coffeeTable.position.set(0, 0, 9);
        coffeeTable.castShadow = true;
        coffeeTable.receiveShadow = true;
        scene.add(coffeeTable);

        // Comfortable Couch facing TV (behind coffee table)
        const couch = new THREE.Group();

        // Main couch base
        const couchBase = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        couchBase.position.y = 0.6;
        couch.add(couchBase);

        // Couch back
        const couchBack = new THREE.Mesh(
            new THREE.BoxGeometry(4, 1.2, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        couchBack.position.y = 1.3;
        couchBack.position.z = -0.75;
        couch.add(couchBack);

        // Couch arms
        const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 1.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        leftArm.position.set(-1.85, 1.3, 0);
        couch.add(leftArm);

        const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 1.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        rightArm.position.set(1.85, 1.3, 0);
        couch.add(rightArm);

        // Couch cushions (3 seat cushions)
        for (let i = 0; i < 3; i++) {
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.15, 1.5),
                new THREE.MeshStandardMaterial({ color: 0x3a5a8b })
            );
            cushion.position.set(-1.3 + i * 1.3, 0.78, 0.1);
            couch.add(cushion);
        }

        // Back cushions
        for (let i = 0; i < 3; i++) {
            const backCushion = new THREE.Mesh(
                new THREE.BoxGeometry(1.1, 0.8, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x3a5a8b })
            );
            backCushion.position.set(-1.3 + i * 1.3, 1.2, -0.65);
            couch.add(backCushion);
        }

        couch.position.set(0, -0.4, 3.5); // Moved back and down to ground level
        couch.castShadow = true;
        couch.receiveShadow = true;
        scene.add(couch);

        // Floor Standing Speaker (corner)
        const speaker = new THREE.Group();

        const speakerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 2.5, 0.8),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        speakerBox.position.y = 1.25;
        speaker.add(speakerBox);

        // Speaker drivers
        const woofer = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        woofer.position.set(0, 0.8, 0.41);
        woofer.rotation.x = Math.PI / 2;
        speaker.add(woofer);

        const tweeter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        tweeter.position.set(0, 1.6, 0.41);
        tweeter.rotation.x = Math.PI / 2;
        speaker.add(tweeter);

        speaker.position.set(12, 0, 12);
        speaker.rotation.y = -Math.PI * 0.75; // Face inward toward center of room
        speaker.castShadow = true;
        scene.add(speaker);

        // Store speaker reference globally for interaction
        window.speakerObject = speaker;


        console.log('Room elements added successfully!');

        // Character creation - Josh Chou
        const characters = [];

        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);

            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);

            // Name label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);

            group.position.set(x, 0, z);
            group.userData = {
                name,
                role,
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };

            characters.push(group);
            return group;
        }

        // Create Josh Chou character
        const josh = createCharacter('Josh Chou', 'Software Engineer & Developer', 0, 0, 0x4169e1, {
            hairColor: 0x3d3d3d,
            personality: 'passionate and innovative',
            quirk: 'always optimizing code and processes'
        });

        scene.add(josh);

        // Collision detection system
        const collisionObjects = [];

        // Function to add collision object
        function addCollisionObject(object, radius = 1) {
            collisionObjects.push({
                object: object,
                radius: radius,
                position: object.position.clone()
            });
        }

        // Function to check collision
        function checkCollision(newPosition) {
            for (let collisionObj of collisionObjects) {
                const distance = newPosition.distanceTo(collisionObj.position);
                if (distance < collisionObj.radius + 0.5) { // 0.5 is player radius
                    return true; // Collision detected
                }
            }
            return false;
        }

        // Add collision objects for furniture and characters
        function setupCollisions() {
            // Add main desk collision
            const mainDesk = scene.getObjectByName('mainDesk') || scene.children.find(child =>
                child.type === 'Group' && child.children.some(c => c.geometry && c.geometry.type === 'BoxGeometry')
            );
            if (mainDesk) {
                addCollisionObject(mainDesk, 2);
            }

            // Add character collisions
            characters.forEach(character => {
                addCollisionObject(character, 0.8);
            });

            // Add plant pot collisions
            const plantPots = scene.children.filter(child =>
                child.geometry && child.geometry.type === 'CylinderGeometry' &&
                child.material && child.material.color && child.material.color.getHex() === 0x8b4513
            );
            plantPots.forEach(plant => {
                addCollisionObject(plant, 0.5);
            });

            // Add plant leaves (bushes) collisions
            const plantLeaves = scene.children.filter(child =>
                child.geometry && child.geometry.type === 'SphereGeometry' &&
                child.material && child.material.color && child.material.color.getHex() === 0x228b22
            );
            plantLeaves.forEach(leaves => {
                addCollisionObject(leaves, 0.8);
            });

            // Add whiteboard collision
            const whiteboard = scene.children.find(child =>
                child.geometry && child.geometry.type === 'BoxGeometry' &&
                child.position.z === -19.8
            );
            if (whiteboard) {
                addCollisionObject(whiteboard, 2);
            }

            console.log(`Added ${collisionObjects.length} collision objects`);
        }

        // Get references to input elements early
        const customQuestionInput = document.getElementById('custom-question-input');
        const customQuestionSubmit = document.getElementById('custom-question-submit');

        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 2),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            isJumping: false,
            jumpVelocity: 0,
            onGround: true,
            groundHeight: 1.6
        };

        const keys = {};

        document.addEventListener('keydown', (e) => {
            // Don't process game controls if typing in the custom question input
            if (document.activeElement === customQuestionInput) {
                // Only process ESC when typing
                if (e.key === 'Escape') {
                    dialogueBox.style.display = 'none';
                    currentCharacter = null;
                    if (document.pointerLockElement === renderer.domElement) {
                        document.exitPointerLock();
                    }
                }
                return;
            }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true; // Store original key for arrow keys

            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }

            // Open computer terminal with 'P' key when near desk
            if (e.key.toLowerCase() === 'c' && window.deskObject && dialogueBox.style.display !== 'block') {
                const deskDistance = player.position.distanceTo(window.deskObject.position);
                console.log('C key pressed! Distance:', deskDistance, 'Desk exists:', !!window.deskObject);
                if (deskDistance < 3) {
                    e.preventDefault();
                    console.log('Opening terminal...');
                    openComputerTerminal();
                }
            }

            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                // Only jump if on ground
                if (player.onGround) {
                    player.isJumping = true;
                    player.jumpVelocity = 0.3; // Initial jump velocity
                    player.onGround = false;
                }
            }

            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            // Don't process game controls if typing in the custom question input
            if (document.activeElement === customQuestionInput) {
                return;
            }

            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false; // Clear original key for arrow keys

            // Note: Jump physics handles completion automatically, no need for keyup handler
        });

        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            // Random events
            if (Math.random() < character.userData.tripChance && !character.userData.isDancing) {
                // Character trips!
                character.rotation.x = Math.PI / 4;
                character.position.y = 0.3;

                setTimeout(() => {
                    character.rotation.x = 0;
                    character.position.y = 0;
                }, 1000);

                character.userData.tripChance = 0;
                setTimeout(() => {
                    character.userData.tripChance = 0.001;
                }, 5000);
            }

            // Don't move if this character is in conversation or dancing
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    // Face the player
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }

            // Random dance party
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }

            character.userData.moveTimer -= deltaTime;

            if (character.userData.moveTimer <= 0) {
                // Set new random target
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );

                // Keep within bounds
                character.userData.targetPosition.x = Math.max(-13, Math.min(13, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-13, Math.min(13, character.userData.targetPosition.z));

                character.userData.moveTimer = 5 + Math.random() * 5;
            }

            // Move towards target
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();

            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));

                // Face movement direction
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;

                // Walking animation
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }

        // Dialogue system with recruitment-focused questions
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');

        let currentCharacter = null;
        let nearbyCharacter = null;

        function generateDialogueOptions(character) {
            // Recruitment-focused questions
            const recruitmentQuestions = [
                // About background and experience
                "Tell me about yourself",
                "What's your work history?",
                "Tell me about your skills and expertise",
                "What are your strongest programming languages?",
                "What's your educational background?",
                "Walk me through your resume",

                // About projects and achievements
                "What's your most impressive project?",
                "Tell me about a challenging problem you solved",
                "What's a project you're proud of?",
                "How do you approach learning new technologies?",
                "What's your development process like?",
                "Tell me about your coding philosophy",

                // About career goals and motivation
                "What are your career goals?",
                "Why are you interested in this field?",
                "What motivates you as a developer?",
                "Where do you see yourself in 5 years?",
                "What kind of role are you looking for?",
                "What's your ideal work environment?",

                // Technical and problem-solving
                "How do you debug complex issues?",
                "Tell me about your testing approach",
                "How do you stay current with technology?",
                "What's your preferred tech stack?",
                "How do you handle technical debt?",
                "Describe your code review process",

                // Soft skills and teamwork
                "How do you work in a team?",
                "Tell me about a time you led a project",
                "How do you handle disagreements with teammates?",
                "What's your communication style?",
                "How do you mentor junior developers?",
                "Describe your leadership style",

                // Fun and personality
                "What do you do outside of work?",
                "What's your favorite part of programming?",
                "Tell me something interesting about yourself",
                "What's your biggest achievement?",
                "What challenges are you looking for?",
                "What questions do you have for me?"
            ];

            // Select 4 random questions
            const shuffled = recruitmentQuestions.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4);
        }

        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name}`;

            // Exit pointer lock when opening dialogue
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }

            const greetings = [
                `Hi! I'm ${character.userData.name}. Thanks for checking out my interactive portfolio! Feel free to ask me anything about my background and experience.`,
                `Hello there! Welcome to my virtual office. I'm ${character.userData.name}, and I'd love to tell you about my journey as a developer.`,
                `Great to meet you! I'm ${character.userData.name}. This is a fun way to learn about my skills and experience - ask me anything!`,
                `Hey! I'm ${character.userData.name}. I built this interactive portfolio to showcase my work in a unique way. What would you like to know?`
            ];

            if (character.userData.conversations.length === 0) {
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
            } else {
                // Show last exchange
                const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
            }

            // Generate dialogue options
            const options = generateDialogueOptions(character);
            dialogueOptions.innerHTML = '';

            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectOption(option);
                dialogueOptions.appendChild(optionDiv);
            });

            // Clear custom question input
            document.getElementById('custom-question-input').value = '';

            // Focus the input for easy typing
            setTimeout(() => {
                document.getElementById('custom-question-input').focus();
            }, 100);
        }

        async function selectOption(option) {
            if (!currentCharacter) return;

            // Show selected option
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${option}</p>`;
            dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;

            // Scroll to bottom of dialogue
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Get references to custom question elements
            const customQuestionInput = document.getElementById('custom-question-input');
            const customQuestionSubmit = document.getElementById('custom-question-submit');

            // Disable options during loading
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';
            customQuestionInput.disabled = true;
            customQuestionSubmit.disabled = true;

            let responseText = "";

            // Generate response based on the question
            responseText = generateJoshResponse(option);

            // Update conversation
            currentCharacter.userData.conversations.push({
                user: option,
                response: responseText
            });

            // Update display
            dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                '<span class="loading"></span>',
                responseText
            );

            // Scroll to bottom
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Random dialogue events
            if (Math.random() < 0.2) {
                createFloatingText('üí°', currentCharacter.position);
            }

            // Generate new options
            const newOptions = generateDialogueOptions(currentCharacter);
            dialogueOptions.innerHTML = '';

            newOptions.forEach(opt => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = opt;
                optionDiv.onclick = () => selectOption(opt);
                dialogueOptions.appendChild(optionDiv);
            });

            // Re-enable options
            dialogueOptions.style.pointerEvents = 'auto';
            dialogueOptions.style.opacity = '1';
            customQuestionInput.disabled = false;
            customQuestionSubmit.disabled = false;
            customQuestionInput.focus();
        }

        // Josh's response generator
        function generateJoshResponse(question) {
            const responses = {
                // About yourself / background
                'tell me about yourself': [
                    "I'm a passionate software engineer with a great product sense. I have experience in full-stack development, cloud technologies, and product management. I love solving complex problems and growing businesses by building innovative solutions that make a real impact.",
                ],

                // Work history and experience
                'work history': [
                    "I've worked across various industries, from startups to enterprise companies, gaining experience in full-stack development, cloud architecture, and team leadership. Each role has taught me valuable lessons about building scalable, maintainable software.",
                    "My career has taken me through different domains - web development, data engineering, and DevOps. I've led teams, architected systems, and always focused on delivering high-quality solutions that solve real business problems.",
                    "I've had the opportunity to work on diverse projects, from building responsive web applications to designing distributed systems. My experience includes both technical leadership and hands-on development across multiple technology stacks."
                ],

                // Skills and expertise
                'skills': [
                    "I'm proficient in JavaScript/TypeScript, Python, and Java, with strong experience in React, Node.js, and cloud platforms like AWS and Azure. I also have expertise in database design, API development, and DevOps practices.",
                    "My technical skills span front-end frameworks like React and Vue.js, backend technologies including Node.js and Django, and cloud infrastructure. I'm also experienced with Docker, Kubernetes, and CI/CD pipelines.",
                    "I specialize in full-stack development with expertise in modern JavaScript frameworks, Python for data processing and APIs, and cloud-native architectures. I'm also skilled in database optimization and system design."
                ],

                // Programming languages
                'programming languages': [
                    "JavaScript/TypeScript is my go-to for web development, Python for data science and backend services, and I also work with Java for enterprise applications. I pick up new languages quickly based on project needs.",
                    "I'm strongest in JavaScript and Python, but I've also worked extensively with Java, Go, and SQL. I believe in choosing the right tool for the job and I'm always eager to learn new languages.",
                    "JavaScript and Python are my primary languages, but I'm comfortable working across the stack. I've used Java for enterprise development, SQL for database work, and I'm always exploring new technologies."
                ],

                // Projects
                'project': [
                    "I built a real-time data visualization platform that processes millions of events per day, using React, Node.js, and Apache Kafka. It reduced data analysis time by 80% and is now used by teams across the organization.",
                    "One of my favorite projects was developing a machine learning pipeline that automated content moderation, reducing manual review time by 70%. It involved Python, TensorFlow, and AWS services for scalable deployment.",
                    "I created a microservices architecture that improved system reliability by 99.9% uptime while reducing deployment time from hours to minutes. The project involved Docker, Kubernetes, and extensive automation."
                ],

                // Challenging problems
                'challenging problem': [
                    "I once had to optimize a database query that was taking 30+ seconds and bringing down our application. Through query optimization, indexing strategies, and caching, I reduced it to under 200ms.",
                    "We had a memory leak in a Node.js application that was causing production crashes. I used profiling tools, analyzed heap dumps, and implemented proper memory management to solve the issue permanently.",
                    "I solved a complex race condition in a distributed system by implementing proper locking mechanisms and redesigning the data flow. It required deep understanding of concurrency and system architecture."
                ],

                // Career goals
                'career goals': [
                    "I want to continue growing as a technical leader while staying hands-on with cutting-edge technologies. My goal is to build systems that scale and mentor other developers along the way.",
                    "I'm focused on becoming a well-rounded engineering leader who can bridge the gap between technical excellence and business impact. I want to work on products that make a meaningful difference.",
                    "My goal is to lead innovative projects that solve real-world problems while continuing to grow my technical expertise. I'm particularly interested in the intersection of AI and software engineering."
                ],

                // Motivation
                'motivates': [
                    "I'm motivated by the opportunity to solve complex problems and see the direct impact of my work. There's nothing quite like the feeling of building something from scratch and watching it help users accomplish their goals.",
                    "What drives me is the constant learning and the collaborative nature of software development. Every project teaches me something new, and working with talented teams to build amazing products is incredibly fulfilling.",
                    "I'm passionate about using technology to make people's lives better. Whether it's improving performance, adding new features, or solving technical challenges, I love the problem-solving aspect of development."
                ],

                // Technical approach
                'debug': [
                    "I approach debugging systematically - reproduce the issue, isolate variables, use logging and debugging tools, and test hypotheses. I also believe in writing comprehensive tests to prevent issues in the first place.",
                    "My debugging process involves understanding the expected vs actual behavior, examining logs, using debugging tools, and thinking through the code flow. I also document solutions for the team's future reference.",
                    "I start with gathering information about the issue, then use a combination of logging, debugging tools, and systematic elimination to identify the root cause. Prevention through good testing is equally important."
                ],

                // Default responses for general questions
                'default': [
                    "That's a great question! I love discussing technology and my experiences. Is there a particular area you'd like to dive deeper into?",
                    "Thanks for asking! I'm passionate about software development and always enjoy sharing my experiences and learning from others.",
                    "Interesting question! I believe in continuous learning and improvement, both in technical skills and in understanding how technology can solve real problems.",
                    "I appreciate your curiosity! Feel free to ask me anything about my technical background, projects, or approach to software development."
                ]
            };

            // Determine response based on question keywords
            let responseKey = 'default';
            const questionLower = question.toLowerCase();

            if (questionLower.includes('yourself') || questionLower.includes('who are you')) responseKey = 'tell me about yourself';
            else if (questionLower.includes('work history') || questionLower.includes('resume') || questionLower.includes('experience')) responseKey = 'work history';
            else if (questionLower.includes('skills') || questionLower.includes('expertise') || questionLower.includes('technologies')) responseKey = 'skills';
            else if (questionLower.includes('programming languages') || questionLower.includes('languages') || questionLower.includes('strongest')) responseKey = 'programming languages';
            else if (questionLower.includes('project') || questionLower.includes('built') || questionLower.includes('impressive')) responseKey = 'project';
            else if (questionLower.includes('challenging') || questionLower.includes('difficult') || questionLower.includes('problem')) responseKey = 'challenging problem';
            else if (questionLower.includes('career goals') || questionLower.includes('future') || questionLower.includes('5 years')) responseKey = 'career goals';
            else if (questionLower.includes('motivates') || questionLower.includes('motivation') || questionLower.includes('passionate')) responseKey = 'motivates';
            else if (questionLower.includes('debug') || questionLower.includes('troubleshoot') || questionLower.includes('solve issues')) responseKey = 'debug';

            const responseArray = responses[responseKey] || responses['default'];
            return responseArray[Math.floor(Math.random() * responseArray.length)];
        }

        // Close dialogue with Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close computer terminal if open
                const terminal = document.getElementById('computer-terminal');
                if (terminal.style.display === 'block') {
                    closeComputerTerminal();
                    return;
                }

                dialogueBox.style.display = 'none';
                currentCharacter = null;
                // Also exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }
        });

        // Set up custom question handlers
        customQuestionSubmit.addEventListener('click', () => {
            const customQuestion = customQuestionInput.value.trim();
            if (customQuestion && currentCharacter) {
                selectOption(customQuestion);
                customQuestionInput.value = '';
            }
        });

        customQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const customQuestion = customQuestionInput.value.trim();
                if (customQuestion && currentCharacter) {
                    selectOption(customQuestion);
                    customQuestionInput.value = '';
                }
            }
        });

        // Contact modal functionality
        const contactTab = document.getElementById('contact-tab');
        const contactModal = document.getElementById('contact-modal');
        const closeContact = document.getElementById('close-contact');

        contactTab.addEventListener('click', () => {
            contactModal.style.display = 'flex';
            // Exit pointer lock if active
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }
        });

        closeContact.addEventListener('click', () => {
            contactModal.style.display = 'none';
        });

        // Close modal when clicking outside
        contactModal.addEventListener('click', (e) => {
            if (e.target === contactModal) {
                contactModal.style.display = 'none';
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                contactModal.style.display = 'none';
                dialogueBox.style.display = 'none';
                currentCharacter = null;
                // Also exit pointer lock if active
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }
        });

        // Social icons hover effects
        const socialIcons = document.querySelectorAll('.social-icon');
        socialIcons.forEach(icon => {
            icon.addEventListener('mouseenter', () => {
                icon.style.transform = 'translateY(-3px) scale(1.1)';
            });

            icon.addEventListener('mouseleave', () => {
                icon.style.transform = 'translateY(0) scale(1)';
            });
        });

        // Animation loop
        let lastTime = 0;
        let animationStarted = false;
        let nearbyPainting = null;
        let tooltipTimeout = null;

        // Painting tooltip data
        const paintingTooltips = {
            'painting1': {
                title: 'Professional Photo 1',
                description: 'My first time winning prize money from pickleball'
            },
            'painting2': {
                title: 'Professional Photo 2',
                description: 'Organizing my rock collection'
            },
            'painting3': {
                title: 'Professional Photo 3',
                description: 'Me and my brother at YC AI Startup school'
            },
            'painting4': {
                title: 'Professional Photo 4',
                description: 'Me!'
            },
            'painting5': {
                title: 'Professional Photo 5',
                description: 'Summiting a mountain'
            },
            'painting6': {
                title: 'Professional Photo 6',
                description: 'Playing my favorite game, mahjong'
            },
            'painting7': {
                title: 'Professional Photo 7',
                description: 'Playing my other favorite game, catan'
            }
        };

        // Function to show painting tooltip
        function showPaintingTooltip(paintingId, worldPosition) {
            const tooltip = document.getElementById('painting-tooltip');
            const title = document.getElementById('tooltip-title');
            const description = document.getElementById('tooltip-description');

            if (paintingTooltips[paintingId]) {
                title.textContent = paintingTooltips[paintingId].title;
                description.textContent = paintingTooltips[paintingId].description;

                // Position tooltip near the top of the screen
                tooltip.style.left = '50%';
                tooltip.style.top = '20px';
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.style.display = 'block';

                nearbyPainting = paintingId;
            }
        }

        // Function to hide painting tooltip
        function hidePaintingTooltip() {
            const tooltip = document.getElementById('painting-tooltip');
            tooltip.style.display = 'none';
            nearbyPainting = null;
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (!animationStarted) {
                console.log('Animation loop started');
                animationStarted = true;
            }

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update player movement (only if dialogue is not open)
            player.velocity.set(0, 0, 0);

            if (dialogueBox.style.display !== 'block') {
                if (keys['w']) player.velocity.z = player.speed;
                if (keys['s']) player.velocity.z = -player.speed;
                if (keys['a']) player.velocity.x = -player.speed;
                if (keys['d']) player.velocity.x = player.speed;
            }

            // Arrow key camera controls (left/right only, disabled during dialogue)
            const lookSpeed = 0.05;
            if (dialogueBox.style.display !== 'block') {
                if (keys['ArrowLeft']) {
                    mouseX += lookSpeed;
                }
                if (keys['ArrowRight']) {
                    mouseX -= lookSpeed;
                }
            }

            // Update camera rotation based on mouse/arrow inputs (horizontal only, disabled during dialogue)
            if (dialogueBox.style.display !== 'block') {
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            }

            // Apply movement in camera direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            // Calculate new position with collision detection
            const newPosition = player.position.clone();
            const forwardMovement = forward.clone().multiplyScalar(player.velocity.z);
            const rightMovement = right.clone().multiplyScalar(player.velocity.x);

            // Try forward movement first
            if (player.velocity.z !== 0) {
                const testPosition = newPosition.clone().add(forwardMovement);
                if (!checkCollision(testPosition)) {
                    newPosition.add(forwardMovement);
                }
            }

            // Try right movement second
            if (player.velocity.x !== 0) {
                const testPosition = newPosition.clone().add(rightMovement);
                if (!checkCollision(testPosition)) {
                    newPosition.add(rightMovement);
                }
            }

            // Update player position
            player.position.copy(newPosition);

            // Keep player in bounds
            player.position.x = Math.max(-13, Math.min(13, player.position.x));
            player.position.z = Math.max(-13, Math.min(13, player.position.z));

            // Apply jump physics
            if (player.isJumping) {
                player.jumpVelocity -= 0.01; // Gravity
                player.position.y += player.jumpVelocity;

                if (player.jumpVelocity < 0 && player.position.y <= player.groundHeight) {
                    player.position.y = player.groundHeight;
                    player.jumpVelocity = 0;
                    player.isJumping = false;
                    player.onGround = true;
                }
            }

            // Update camera position to follow player
            if (dialogueBox.style.display !== 'block') {
                camera.position.copy(player.position);
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
                camera.rotation.z = 0;
            }

            // Update character movement
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);

                // Dancing animation
                if (character.userData.isDancing) {
                    character.rotation.y += 0.1;
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;

                    // Arm waving
                    character.userData.leftArm.rotation.z = Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
                    character.userData.rightArm.rotation.z = -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
                }
            });

            // Check for nearby characters
            nearbyCharacter = null;
            let minDistance = Infinity;

            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 3 && distance < minDistance) {
                    minDistance = distance;
                    nearbyCharacter = character;
                }
            });

            // Show/hide interaction prompt (only when dialogue is not open)
            if (nearbyCharacter && !currentCharacter) {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to Talk`;
            } else {
                interactionPrompt.style.display = 'none';
            }

            // Check for nearby paintings
            let closestPainting = null;
            let closestPaintingDistance = Infinity;

            paintings.forEach(painting => {
                const distance = player.position.distanceTo(painting.painting.position);
                if (distance < 4 && distance < closestPaintingDistance) {
                    closestPaintingDistance = distance;
                    closestPainting = painting;
                }
            });

            // Show/hide painting tooltip
            if (closestPainting && closestPaintingDistance < 4) {
                showPaintingTooltip(closestPainting.data.id, closestPainting.painting.position);
            } else {
                hidePaintingTooltip();
            }

            // Check for speaker proximity
            if (window.speakerObject) {
                const speakerDistance = player.position.distanceTo(window.speakerObject.position);
                const speakerTooltip = document.getElementById('speaker-tooltip');

                if (speakerDistance < 4) {
                    // Show speaker tooltip
                    speakerTooltip.style.display = 'block';

                    // Position tooltip near speaker
                    const speakerTopPos = window.speakerObject.position.clone();
                    speakerTopPos.y += 2.5; // Add speaker height to get the top
                    speakerTopPos.project(camera);

                    const x = (speakerTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (speakerTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the speaker with some margin
                    speakerTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    speakerTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    speakerTooltip.style.display = 'none';
                }
            }

            // Check for TV proximity
            if (window.tvObject) {
                const tvDistance = player.position.distanceTo(window.tvObject.position);
                const tvTooltip = document.getElementById('tv-tooltip');

                if (tvDistance < 4) {
                    // Show TV tooltip
                    tvTooltip.style.display = 'block';

                    // Position tooltip above TV (using the top of the TV)
                    const tvTopPos = window.tvObject.position.clone();
                    tvTopPos.y += 3; // Add TV height to get the top
                    tvTopPos.project(camera);

                    const x = (tvTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (tvTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the TV with some margin
                    tvTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    tvTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    tvTooltip.style.display = 'none';
                }
            }

            // Check for bookshelf proximity
            if (window.bookshelfObject) {
                const bookshelfDistance = player.position.distanceTo(window.bookshelfObject.position);
                const bookshelfTooltip = document.getElementById('bookshelf-tooltip');

                if (bookshelfDistance < 4) {
                    // Show bookshelf tooltip
                    bookshelfTooltip.style.display = 'block';

                    // Position tooltip above bookshelf (using the top of the bookshelf)
                    const bookshelfTopPos = window.bookshelfObject.position.clone();
                    bookshelfTopPos.y += 2.5; // Add bookshelf height to get the top
                    bookshelfTopPos.project(camera);

                    const x = (bookshelfTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (bookshelfTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the bookshelf with some margin
                    bookshelfTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    bookshelfTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    bookshelfTooltip.style.display = 'none';
                }
            }

            // Check for computer/desk proximity
            if (window.deskObject) {
                const deskDistance = player.position.distanceTo(window.deskObject.position);

                if (deskDistance < 3) {
                    // Show computer interaction prompt
                    if (nearbyCharacter === null && !currentCharacter) {
                        interactionPrompt.style.display = 'block';
                        interactionPrompt.textContent = `Press C to Access Computer (Projects)`;
                    }
                } else {
                    // Only hide prompt if it's showing computer message
                    if (interactionPrompt.textContent.includes('Computer')) {
                        interactionPrompt.style.display = 'none';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse look (horizontal only)
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement && dialogueBox.style.display !== 'block') {
                mouseX += e.movementX * 0.002;
            }
        });

        renderer.domElement.addEventListener('click', () => {
            if (!dialogueBox.style.display || dialogueBox.style.display === 'none') {
                renderer.domElement.requestPointerLock();
            }
        });

        // Computer terminal functions
        function openComputerTerminal() {
            const terminal = document.getElementById('computer-terminal');
            terminal.style.display = 'block';
            // Disable game controls when terminal is open
            document.body.style.pointerEvents = 'auto';
        }

        function closeComputerTerminal() {
            const terminal = document.getElementById('computer-terminal');
            terminal.style.display = 'none';
            // Re-enable game controls
            document.body.style.pointerEvents = 'none';
            document.querySelector('canvas').style.pointerEvents = 'auto';
        }

        // Make functions globally available
        window.openComputerTerminal = openComputerTerminal;
        window.closeComputerTerminal = closeComputerTerminal;

        console.log('Starting animation...');

        // Setup collision detection
        setupCollisions();

        animate(0);

        // Animation loop
    </script>
</body>
</html>