<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Josh Chou - Interactive Portfolio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        #ui-overlay h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #ui-overlay p {
            margin: 8px 0;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.4;
        }

        #dialogue-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.65);
            color: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 1000;
        }

        #dialogue-box h3 {
            margin: 0 0 15px 0;
            color: rgba(255, 255, 255, 1);
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        #dialogue-content {
            margin: 15px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
            color: rgba(255, 255, 255, 1);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .dialogue-option {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin: 10px 0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
        }

        .dialogue-option:hover {
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 1);
            transform: translateX(5px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        }

        /* Custom question styles removed - only predetermined questions now */

        /* Painting Tooltip Styles */
        .painting-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 2000;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .painting-tooltip h4 {
            display: none;
        }

        .painting-tooltip p {
            margin: 0;
            color: #333;
            line-height: 1.4;
            font-weight: 500;
        }

        /* Speaker Tooltip Styles */
        .speaker-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            max-width: 300px;
            display: none;
            z-index: 2000;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .speaker-tooltip h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
            font-weight: bold;
        }

        .speaker-tooltip p {
            margin: 0;
            color: #333;
            line-height: 1.4;
        }

        /* Computer Terminal Popup Styles */
        .computer-terminal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            height: 70%;
            background: #1a1a1a;
            border: 3px solid #333;
            border-radius: 8px;
            display: none;
            z-index: 3000;
            font-family: 'Courier New', monospace;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
        }

        .terminal-header {
            background: #333;
            padding: 10px 15px;
            border-bottom: 1px solid #555;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            color: #00ff00;
            font-weight: bold;
            font-size: 14px;
        }

        .terminal-close {
            background: #ff4444;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .terminal-close:hover {
            background: #ff6666;
        }

        .terminal-content {
            padding: 20px;
            height: calc(100% - 60px);
            overflow-y: auto;
            color: #00ff00;
            font-size: 14px;
            line-height: 1.6;
            background: #1a1a1a;
        }

        .terminal-content::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: #333;
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .project-item {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #222;
        }

        .project-title {
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .project-tech {
            color: #ffff00;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .project-description {
            color: #00ff00;
            margin-bottom: 10px;
        }

        .project-link {
            color: #ff00ff;
            text-decoration: underline;
            cursor: pointer;
        }

        .project-link:hover {
            color: #ff66ff;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(65, 105, 225, 0.3);
            border-radius: 50%;
            border-top-color: #4169e1;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }

        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }

        .floating-text {
            position: absolute;
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        /* Contact Tab Styles */
        #contact-tab {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        #contact-tab:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 16px 56px rgba(0, 0, 0, 0.25), 0 6px 20px rgba(0, 0, 0, 0.15);
            color: #ffffff;
        }

        #contact-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        #contact-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 24px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2), 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #contact-content h2 {
            margin: 0 0 20px 0;
            color: rgba(255, 255, 255, 0.95);
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #contact-content p {
            margin: 15px 0;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.6;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .contact-button {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            margin: 10px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .contact-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #close-contact {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 18px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #close-contact:hover {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 1);
            transform: scale(1.1);
        }

        /* Social Icons Styles */
        #social-icons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .social-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: white;
            font-size: 20px;
            transition: all 0.3s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .social-icon:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 16px 56px rgba(0, 0, 0, 0.25), 0 6px 20px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .social-icon.github {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.github:hover {
            background: rgba(36, 41, 46, 0.8);
        }

        .social-icon.linkedin {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.linkedin:hover {
            background: rgba(0, 119, 181, 0.8);
        }

        .social-icon.twitter {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.twitter:hover {
            background: rgba(29, 161, 242, 0.8);
        }

        .social-icon.email {
            background: rgba(255, 255, 255, 0.1);
        }

        .social-icon.email:hover {
            background: rgba(234, 67, 53, 0.8);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <h2 id="title">Josh Chou's Den</h2>
        <p id="move-instruction">Use WASD to move around</p>
        <p id="look-instruction">Arrow keys to look left/right</p>
        <p id="interact-instruction">Press E to interact</p>
        <p id="dance-instruction">Press SPACE to jump</p>
        <p id="close-instruction">Press ESC to close dialogs</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Interact with me and the computer!</p>
        <p class="instruction" style="margin-top: 10px;" id="tip-instruction">üí° Explore the room to learn more about me!</p>
    </div>

    <div id="dialogue-box">
        <h3 id="dialogue-name">Name</h3>
        <div id="dialogue-content">Content</div>
        <div id="dialogue-options"></div>
        <!-- Custom questions removed - only predetermined questions available -->
    </div>

    <div id="painting-tooltip" class="painting-tooltip">
        <h4 id="tooltip-title">Painting Title</h4>
        <p id="tooltip-description">Placeholder description for this painting.</p>
    </div>

    <div id="speaker-tooltip" class="speaker-tooltip">
        <h4>My current rotation (as of 7/24/25)</h4>
        <p>Daisies - Justin Bieber<br>
        Follows You - Michael Marcagi<br>
        Strawberry Swing - Coldplay<br>
        Little Bit More - Mk.gee<br>
        Saving Up - Dom Dolla</p>
    </div>

    <div id="tv-tooltip" class="speaker-tooltip">
        <h4>My Favorite Movies</h4>
        <p>How to Train Your Dragon<br>
        Real Steel<br>
        Interstellar<br>
        Tenet<br>
        Dune Pt 2</p>
    </div>

    <div id="bookshelf-tooltip" class="speaker-tooltip">
        <h4>My Favorite Books</h4>
        <p>Red Rising - Pierce Brown<br>
        Bewilderment - Richard Powers<br>
        Open - Andre Agassi<br>
        The Martian - Andy Weir<br>
        One Flew Over the Cuckoo's Nest - Ken Kesey</p>
    </div>

    <!-- Computer Terminal Popup -->
    <div id="computer-terminal" class="computer-terminal">
        <div class="terminal-header">
            <div class="terminal-title">josh@portfolio:~/projects$</div>
            <button class="terminal-close" onclick="closeComputerTerminal()">√ó</button>
        </div>
        <div class="terminal-content">
            <div style="color: #00ffff; margin-bottom: 20px;">> ls -la projects/</div>

            <div class="project-item">
                <div class="project-title">üõ°Ô∏è AWS Real-Time Fraud Detection</div>
                <div class="project-tech">Tech: TypeScript, GraphQL, AWS Lambda, Kinesis, SQS, SNS</div>
                <div class="project-description">üèÜ AWS Spark Fair Winner - High-throughput real-time fraud detection workflow processing 50M AWS activity logs daily. Reduced fraud detection time from 15-60 minutes to seconds (95% improvement). Recognized as top-performing intern across all disciplines.</div>
                <div class="project-link">Internship: June-September 2024 | Award: Amazon AWS Spark Fair</div>
            </div>

            <div class="project-item">
                <div class="project-title">üöó TestDrive.AI</div>
                <div class="project-tech">Tech: Python, OpenCV, PyTorch, YOLOV8, Intel oneAPI, Next.js, Tailwind</div>
                <div class="project-description">Full-stack computer vision application that automates driving test evaluations by analyzing dash-cam and driver-facing footage to detect violations such as lane drifting, tailgating, and smartphone usage.</div>
                <div class="project-link">Project: October 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üß† Codenames Clue Analyzer</div>
                <div class="project-tech">Tech: Python, Hugging Face API, TensorFlow, NLP</div>
                <div class="project-description">AI tool to analyze and score clues in the board game Codenames to increase win rate. Integrated semantic relationship ML model and devised accurate scoring algorithm to determine clue strength.</div>
                <div class="project-link">Project: December 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üîç Mini Google</div>
                <div class="project-tech">Tech: C, C++, Valgrind, GDB</div>
                <div class="project-description">Modular search engine with file system crawler, in-memory query processor, and persistent index storage using architecture-neutral marshalling. Implemented multithreaded web server interface supporting concurrent search requests.</div>
                <div class="project-link">Project: November 2023</div>
            </div>

            <div class="project-item">
                <div class="project-title">üóÇÔ∏è Distributed Key-Value Store</div>
                <div class="project-tech">Tech: Go, RPC, Paxos Consensus Algorithm</div>
                <div class="project-description">Scalable key-value store with sharding, replication, and fault tolerance. Built custom RPC framework with exactly-once semantics. Implemented Paxos consensus for strong consistency and dynamic reconfiguration for shard migration.</div>
                <div class="project-link">Course Project: Distributed Systems</div>
            </div>

            <div class="project-item">
                <div class="project-title">‚è∞ WakeBox</div>
                <div class="project-tech">Tech: Hardware Integration, Mobile Development</div>
                <div class="project-description">üèÜ DubHacks Winner - Multifunctional alarm clock integrating physical and mental tasks for deactivation. Won first place at the largest hackathon in the PNW with 12,000+ competitors.</div>
                <div class="project-link">Award: March 2023 - DubHacks Hackathon Winner</div>
            </div>

            <div style="color: #00ffff; margin-top: 30px;">> Total projects: 6 | Awards: 2 üèÜ</div>
            <div style="color: #ffff00; margin-top: 10px;">> üéì UW Computer Science | 3.8 GPA | June 2026</div>
            <div style="color: #ffff00; margin-top: 5px;">> üöÄ Y Combinator AI Startup School Alumni | Top 2000 globally</div>
            <div style="color: #ffff00; margin-top: 5px;">> üíº Current: AWS SDE Intern | Affable BPM Founding Engineer | OdysseyHydration CTO</div>
            <div style="color: #00ff00; margin-top: 15px;">> Press 'ESC' to close terminal</div>
        </div>
    </div>

    <div id="interaction-prompt"></div>

    <!-- Contact Tab -->
    <div id="contact-tab">Contact</div>

    <!-- Contact Modal -->
    <div id="contact-modal">
        <div id="contact-content">
            <button id="close-contact">&times;</button>
            <h2>Get In Touch</h2>
            <p>I'm always interested in new opportunities and collaborations. Feel free to reach out!</p>
            <a href="mailto:joshchouprofessional@outlook.com" class="contact-button">üìß Send Email</a>
            <a href="JoshChouResume.pdf" class="contact-button" download>üìÑ Download Resume</a>
            <p style="margin-top: 20px; font-size: 14px; color: #999;">
                Available for freelance work and full-time opportunities
            </p>
        </div>
    </div>

    <!-- Social Icons -->
    <div id="social-icons">
        <a href="https://github.com/jcthewizard" target="_blank" class="social-icon github" title="GitHub">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
        </a>
        <a href="https://linkedin.com/in/joshchou7" target="_blank" class="social-icon linkedin" title="LinkedIn">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
        </a>
        <!-- <a href="https://twitter.com/jcthewizard" target="_blank" class="social-icon twitter" title="Twitter">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
            </svg>
        </a> -->
        <a href="mailto:joshchouprofessional@outlook.com" class="social-icon email" title="Email">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M0 3v18h24V3H0zm21.518 2L12 12.713 2.482 5h19.036zM2 19V7.183l10 8.104 10-8.104V19H2z"/>
            </svg>
        </a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log('Starting Josh Chou Interactive Portfolio...');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        console.log('Scene, camera, and renderer initialized');

        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);

            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);

            setTimeout(() => div.remove(), 2000);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Floor with pattern
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Add floor tiles pattern
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });

        for (let x = -15; x < 15; x += 2) {
            for (let z = -15; z < 15; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }

        // Walls with windows
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8f8f8,  // Much lighter gray color
            roughness: 0.9
        });

        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });

        // Back wall with windows
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        backWall.position.set(0, 5, -15);
        backWall.receiveShadow = true;
        backWall.castShadow = false;
        scene.add(backWall);

        // Add windows to back wall - REMOVED
        // for (let x = -10; x <= 10; x += 8) {
        //     const window = new THREE.Mesh(
        //         new THREE.PlaneGeometry(3, 2.5),
        //         windowMaterial
        //     );
        //     window.position.set(x, 5, -14.9);
        //     scene.add(window);
        // }

        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        leftWall.position.set(-15, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        leftWall.castShadow = false;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        rightWall.position.set(15, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        rightWall.castShadow = false;
        scene.add(rightWall);

        // Front wall
        const frontWall = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 10),
            wallMaterial
        );
        frontWall.position.set(0, 5, 15);
        frontWall.rotation.y = Math.PI;
        frontWall.receiveShadow = true;
        frontWall.castShadow = false;
        scene.add(frontWall);

        // Ceiling
        const ceilingMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8,
            metalness: 0.1
        });

        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 30),
            ceilingMaterial
        );
        ceiling.position.set(0, 10, 0);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.receiveShadow = true;
        ceiling.castShadow = false;
        scene.add(ceiling);

        // Office furniture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });

        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });

        // Create a single main desk for Josh
        function createMainDesk(x, z) {
            const deskGroup = new THREE.Group();

            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);

            // Metal frame
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];

            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });

            // Computer monitor (dual setup)
            const monitorBase1 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase1.position.set(-0.5, 0.82, 0);
            deskGroup.add(monitorBase1);

            const monitorBase2 = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase2.position.set(0.5, 0.82, 0);
            deskGroup.add(monitorBase2);

            const monitorStand1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand1.position.set(-0.5, 0.95, 0);
            deskGroup.add(monitorStand1);

            const monitorStand2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand2.position.set(0.5, 0.95, 0);
            deskGroup.add(monitorStand2);

            const monitorScreen1 = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen1.position.set(-0.5, 1.3, 0);
            deskGroup.add(monitorScreen1);

            const monitorScreen2 = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen2.position.set(0.5, 1.3, 0);
            deskGroup.add(monitorScreen2);

            // Keyboard
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);

            // Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);

            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);

            // Coffee mug
            const mug = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            mug.position.set(0.8, 0.85, 0.2);
            deskGroup.add(mug);

            // Notebook
            const notebook = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.01, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x4169e1 })
            );
            notebook.position.set(-0.8, 0.81, 0.2);
            deskGroup.add(notebook);

            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }

        // Add Josh's main desk
        const mainDesk = createMainDesk(0, -5);
        scene.add(mainDesk);

        // Store desk reference globally for interaction
        window.deskObject = mainDesk;
        console.log('Desk object stored at position:', mainDesk.position);

        // Add whiteboard with "Josh Chou" written on it
        const whiteboardMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1
        });

        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            whiteboardMaterial
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = false;
        scene.add(whiteboard);
        // Gallery System - Multiple Interactive Paintings Around the Walls
        console.log('Setting up interactive gallery system...');

        const paintings = [];
        const paintingData = [
            // Back wall paintings - gallery style with equal spacing and height
            { id: 'painting1', name: 'Art Piece 1', position: [-9, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Far left
            { id: 'painting2', name: 'Art Piece 2', position: [-6, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Left
            { id: 'painting3', name: 'Art Piece 3', position: [-3, 1.7, -14.7], size: [2.4, 2.7], media: null }, // Left center (your photo - slightly wider)
            { id: 'painting4', name: 'Art Piece 4', position: [0, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Center
            { id: 'painting5', name: 'Art Piece 5', position: [3, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Right center
            { id: 'painting6', name: 'Art Piece 6', position: [6, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Right
            { id: 'painting7', name: 'Art Piece 7', position: [9, 1.7, -14.7], size: [2.1, 2.7], media: null }, // Far right
        ];

        // Create default fallback material for empty paintings
        function createEmptyPaintingMaterial(paintingName) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(1, '#d0d0d0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Add text
            ctx.fillStyle = '#666';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Portfolio Image', 256, 200);
            ctx.font = '24px Arial';
            ctx.fillText(paintingName, 256, 240);
            ctx.fillText('üì∑', 256, 300);

            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.3,
                metalness: 0.1
            });
        }

        // Create uniform paintings
        function createPainting(data) {
            // Create frame (all frames are identical brown wood)
            const frameGeometry = new THREE.BoxGeometry(data.size[0] + 0.3, data.size[1] + 0.3, 0.25);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513, // Brown wood color for all frames
                roughness: 0.6,
                metalness: 0.1
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(...data.position.map((p, i) => i === 2 ? p - 0.15 : p));
            if (data.rotation) frame.rotation.set(...data.rotation);
            frame.castShadow = true;
            frame.receiveShadow = true;
            scene.add(frame);

            // Create painting with empty material
            const paintingGeometry = new THREE.PlaneGeometry(...data.size);
            const painting = new THREE.Mesh(paintingGeometry, createEmptyPaintingMaterial(data.name));
            painting.position.set(...data.position);
            if (data.rotation) painting.rotation.set(...data.rotation);
            painting.userData = { paintingId: data.id, frame: frame, isEmpty: true };
            painting.userData.originalMaterial = painting.material;
            scene.add(painting);

            paintings.push({ painting, frame, data, media: null });
            return painting;
        }

        // Setup all paintings uniformly
        paintingData.forEach(data => {
            createPainting(data);
        });

        console.log(`Gallery setup complete - ${paintings.length} paintings created`);

        // Hardcoded Gallery Content
        console.log('Loading predefined gallery content...');

        // Define content for each painting (you can easily modify these)
        const galleryContent = {
            'painting1': {
                type: 'image',
                title: 'Professional Photo 1',
                src: 'images/IMG_0597.JPEG',
                description: 'Portfolio Image'
            },
            'painting2': {
                type: 'image',
                title: 'Professional Photo 2',
                src: 'images/IMG_9022.jpeg',
                description: 'Portfolio Image'
            },
            'painting3': {
                type: 'image',
                title: 'Professional Photo 3',
                src: 'images/IMG_1698%202.jpeg',
                description: 'Portfolio Image'
            },
            'painting4': {
                type: 'image',
                title: 'Professional Photo 4',
                src: 'images/1722728684041.jpeg',
                description: 'Portfolio Image'
            },
            'painting5': {
                type: 'image',
                title: 'Professional Photo 5',
                src: 'images/IMG_4678.JPG',
                description: 'Portfolio Image'
            },
            'painting6': {
                type: 'image',
                title: 'Professional Photo 6',
                src: 'images/IMG_7509.jpeg',
                description: 'Portfolio Image'
            },
            'painting7': {
                type: 'image',
                title: 'Professional Photo 7',
                src: 'images/IMG_8477.jpeg',
                description: 'Portfolio Image'
            }
        };

        // Function to create canvas-based placeholder
        function createCanvasPlaceholder(content) {
            console.log(`Creating canvas placeholder for ${content.title} with color ${content.color}`);

            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 600;
            const ctx = canvas.getContext('2d');

            // Background - make it more distinctive
            ctx.fillStyle = content.color;
            ctx.fillRect(0, 0, 800, 600);

            // Add border to make it more visible
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, 790, 590);

            // Add some pattern - large circles
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.arc(
                    100 + (i % 4) * 150,
                    150 + Math.floor(i / 4) * 200,
                    50, 0, Math.PI * 2
                );
                ctx.fill();
            }

            // Title - make it much more visible
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeText(content.title, 400, 200);
            ctx.fillText(content.title, 400, 200);

            // Description
            ctx.font = 'bold 40px Arial';
            ctx.strokeText(content.description, 400, 280);
            ctx.fillText(content.description, 400, 280);

            // Large icon
            ctx.font = '80px Arial';
            ctx.strokeText('üöÄ', 400, 400);
            ctx.fillText('üöÄ', 400, 400);

            // Add "CANVAS" text to make it obvious this is canvas content
            ctx.font = 'bold 24px Arial';
            ctx.fillStyle = '#FFFF00';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeText('CANVAS CONTENT', 400, 500);
            ctx.fillText('CANVAS CONTENT', 400, 500);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.2,
                metalness: 0.1
            });

            console.log(`Created canvas material for ${content.title}`, material);
            return material;
        }

        // Function to load predefined content into paintings
        function loadGalleryContent() {
            console.log('Starting to load gallery content for', paintings.length, 'paintings');
            console.log('Available gallery content keys:', Object.keys(galleryContent));

            paintings.forEach((paintingObj, index) => {
                const content = galleryContent[paintingObj.data.id];
                if (!content) {
                    console.log(`No content found for ${paintingObj.data.id}`);
                    return; // Skip undefined content
                }

                console.log(`Loading ${content.title} into ${paintingObj.data.id} (index ${index})`);
                console.log(`Painting position:`, paintingObj.data.position);
                console.log(`Painting rotation:`, paintingObj.data.rotation);

                if (content.type === 'canvas') {
                    // Create canvas-based material
                    const newMaterial = createCanvasPlaceholder(content);
                    paintingObj.painting.material = newMaterial;
                    paintingObj.painting.material.needsUpdate = true;
                    console.log(`Applied canvas material to ${paintingObj.data.id}`, newMaterial);

                } else if (content.type === 'video') {
                    // Create video element
                    const video = document.createElement('video');
                    video.src = content.src;
                    video.loop = true;
                    video.muted = true;
                    video.crossOrigin = 'anonymous';
                    video.playsInline = true;
                    video.autoplay = false;

                    const videoTexture = new THREE.VideoTexture(video);
                    videoTexture.minFilter = THREE.LinearFilter;
                    videoTexture.magFilter = THREE.LinearFilter;
                    videoTexture.format = THREE.RGBFormat;

                    video.addEventListener('loadeddata', () => {
                        console.log(`Video ${content.title} loaded`);
                        paintingObj.painting.material = new THREE.MeshStandardMaterial({
                            map: videoTexture,
                            roughness: 0.1,
                            metalness: 0.1
                        });
                    });

                    video.addEventListener('canplay', () => {
                        video.play().catch(e => console.log('Video autoplay failed:', e));
                    });

                    video.load();
                    paintingObj.media = video;

                } else {
                    // Create image texture
                    const img = new Image();
                    // Remove crossOrigin for localhost to avoid CORS issues
                    // img.crossOrigin = 'anonymous';

                    console.log(`Attempting to load image: ${content.src}`);

                    img.onload = () => {
                        console.log(`Image ${content.title} loaded successfully`);
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;

                        paintingObj.painting.material = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.2,
                            metalness: 0.1
                        });
                        console.log(`Applied texture to ${paintingObj.data.id}`);
                    };

                    img.onerror = (error) => {
                        console.error(`Failed to load ${content.title} from ${content.src}:`, error);
                        console.log(`Using fallback material for ${paintingObj.data.id}`);
                        console.log(`Image error details:`, error);
                        console.log(`Attempted URL:`, content.src);
                        console.log(`Painting ID:`, paintingObj.data.id);
                        // Keep the original "Portfolio Image" material as fallback
                    };

                    // Set the source after setting up event handlers
                    img.src = content.src;
                    paintingObj.media = img;
                }

                // Brown frame for all content types
                paintingObj.frame.material.color.setHex(0x8b4513);

                // Update painting userData
                paintingObj.data.isEmpty = false;
                paintingObj.data.title = content.title;
            });

            console.log('Finished loading gallery content');
        }

        // Load all gallery content
        loadGalleryContent();

        console.log('Gallery content loaded successfully!');

        // Plant decorations
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-10, 0.2, -10);
        scene.add(plantPot);

        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-10, 0.8, -10);
        scene.add(plantLeaves);

        // Add more plants
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(10, 0.2, -10);
        scene.add(plantPot2);

        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(10, 0.8, -10);
        scene.add(plantLeaves2);

        // Additional Room Elements to Liven Things Up
        console.log('Adding substantial room elements...');

        // Large Bookshelf (left side of room) - more realistic
        function createBookshelf(x, z) {
            const bookshelfGroup = new THREE.Group();

            // Main frame materials
            const shelfMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.7 });
            const darkWoodMaterial = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.8 });

            // Vertical sides
            const leftSide = new THREE.Mesh(new THREE.BoxGeometry(0.15, 6, 1), shelfMaterial);
            leftSide.position.set(-1.9, 3, 0);
            bookshelfGroup.add(leftSide);

            const rightSide = new THREE.Mesh(new THREE.BoxGeometry(0.15, 6, 1), shelfMaterial);
            rightSide.position.set(1.9, 3, 0);
            bookshelfGroup.add(rightSide);

            // Back panel
            const backPanel = new THREE.Mesh(new THREE.BoxGeometry(3.8, 5.8, 0.1), darkWoodMaterial);
            backPanel.position.set(0, 3, -0.45);
            bookshelfGroup.add(backPanel);

            // Top and bottom panels
            const topPanel = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 1), shelfMaterial);
            topPanel.position.set(0, 5.9, 0);
            bookshelfGroup.add(topPanel);

            const bottomPanel = new THREE.Mesh(new THREE.BoxGeometry(4, 0.15, 1), shelfMaterial);
            bottomPanel.position.set(0, 0.1, 0);
            bookshelfGroup.add(bottomPanel);

            // Shelves (4 internal shelves)
            for (let i = 0; i < 4; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(3.7, 0.1, 0.9), shelfMaterial);
                shelf.position.y = (i + 1) * 1.4 + 0.2;
                bookshelfGroup.add(shelf);

                // Add books on each shelf - no randomness, consistent placement
                let currentX = -1.6; // Start at left edge
                const booksOnShelf = 7; // Fixed number of books per shelf

                for (let j = 0; j < booksOnShelf; j++) {
                    const bookColors = [0x8b0000, 0x006400, 0x4b0082, 0xff4500, 0x2f4f4f, 0x800080, 0x556b2f, 0x8b008b, 0x000080, 0x8b4513];
                    const bookWidth = 0.12; // Fixed width for all books
                    const bookHeight = 0.6 + Math.random() * 0.4; // Random height between 0.6 and 1.0
                    const baseY = (i + 1) * 1.4 + 0.2 - 1.34; // Base level for all books on this shelf

                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(bookWidth, bookHeight, 0.05),
                        new THREE.MeshStandardMaterial({ color: bookColors[j % bookColors.length] })
                    );

                    // Position books with same base but varying heights
                    book.position.set(
                        currentX + bookWidth/2,
                        baseY + bookHeight/2, // Base stays same, height varies upward
                        0.2 // Fixed depth within shelf
                    );
                    book.rotation.y = 0; // No rotation - all books perfectly aligned
                    bookshelfGroup.add(book);

                    currentX += bookWidth + 0.01; // Fixed gap between books

                    if (currentX > 1.4) break; // Stop before shelf edge
                }

            }

            bookshelfGroup.position.set(x, 0, z);
            bookshelfGroup.rotation.y = Math.PI; // Turn it around to face inward
            bookshelfGroup.castShadow = true;
            bookshelfGroup.receiveShadow = true;
            return bookshelfGroup;
        }

        const mainBookshelf = createBookshelf(-10, 13.5); // Pushed further back towards TV wall
        scene.add(mainBookshelf);

        // Store bookshelf reference globally for interaction
        window.bookshelfObject = mainBookshelf;
        console.log('Bookshelf object stored at position:', mainBookshelf.position);

        // Large TV on front wall (opposite the gallery)
        const tvGroup = new THREE.Group();

        // TV frame/bezel
        const tvFrame = new THREE.Mesh(
            new THREE.BoxGeometry(5, 3, 0.1),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        tvFrame.position.y = 2;
        tvGroup.add(tvFrame);

        // TV screen
        const tvScreen = new THREE.Mesh(
            new THREE.PlaneGeometry(4.6, 2.6),
            new THREE.MeshStandardMaterial({
                color: 0x000033,
                emissive: 0x000011,
                roughness: 0.1,
                metalness: 0.1
            })
        );
        tvScreen.position.set(0, 2, 0.06);
        tvGroup.add(tvScreen);

        // TV stand/mount
        const tvStand = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.5, 0.2),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        tvStand.position.set(0, 0.5, -0.1);
        tvGroup.add(tvStand);

        tvGroup.position.set(0, 0, 14.2);
        tvGroup.castShadow = true;
        scene.add(tvGroup);

        // Store TV reference globally for interaction
        window.tvObject = tvGroup;
        console.log('TV object stored at position:', tvGroup.position);

        // Large Area Rug - moved closer to TV
        const areaRug = new THREE.Mesh(
            new THREE.PlaneGeometry(8, 6),
            new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.8,
                metalness: 0.1
            })
        );
        areaRug.rotation.x = -Math.PI / 2;
        areaRug.position.set(0, 0.02, 8);
        areaRug.receiveShadow = true;
        scene.add(areaRug);

        // Coffee Table on the rug - moved closer to TV
        const coffeeTable = new THREE.Group();

        // Table top
        const coffeeTableTop = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.1, 1.2),
            new THREE.MeshStandardMaterial({ color: 0x654321 })
        );
        coffeeTableTop.position.y = 0.4;
        coffeeTable.add(coffeeTableTop);

        // Table legs
        const legPositions = [[-1, 0.2, -0.5], [1, 0.2, -0.5], [-1, 0.2, 0.5], [1, 0.2, 0.5]];
        legPositions.forEach(pos => {
            const leg = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x654321 })
            );
            leg.position.set(...pos);
            coffeeTable.add(leg);
        });

        // Items on coffee table
        const magazine = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.02, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        magazine.position.set(-0.5, 0.46, 0.2);
        magazine.rotation.y = 0.3;
        coffeeTable.add(magazine);

        const tvRemote = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.03, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        tvRemote.position.set(0.4, 0.46, -0.2);
        coffeeTable.add(tvRemote);

        coffeeTable.position.set(0, 0, 9);
        coffeeTable.castShadow = true;
        coffeeTable.receiveShadow = true;
        scene.add(coffeeTable);

        // Comfortable Couch facing TV (behind coffee table)
        const couch = new THREE.Group();

        // Main couch base
        const couchBase = new THREE.Mesh(
            new THREE.BoxGeometry(4, 0.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        couchBase.position.y = 0.6;
        couch.add(couchBase);

        // Couch back
        const couchBack = new THREE.Mesh(
            new THREE.BoxGeometry(4, 1.2, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        couchBack.position.y = 1.3;
        couchBack.position.z = -0.75;
        couch.add(couchBack);

        // Couch arms
        const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 1.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        leftArm.position.set(-1.85, 1.3, 0);
        couch.add(leftArm);

        const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 1.2, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x2d4a7b })
        );
        rightArm.position.set(1.85, 1.3, 0);
        couch.add(rightArm);

        // Couch cushions (3 seat cushions)
        for (let i = 0; i < 3; i++) {
            const cushion = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.15, 1.5),
                new THREE.MeshStandardMaterial({ color: 0x3a5a8b })
            );
            cushion.position.set(-1.3 + i * 1.3, 0.78, 0.1);
            couch.add(cushion);
        }

        // Back cushions
        for (let i = 0; i < 3; i++) {
            const backCushion = new THREE.Mesh(
                new THREE.BoxGeometry(1.1, 0.8, 0.2),
                new THREE.MeshStandardMaterial({ color: 0x3a5a8b })
            );
            backCushion.position.set(-1.3 + i * 1.3, 1.2, -0.65);
            couch.add(backCushion);
        }

        couch.position.set(0, -0.4, 3.5); // Moved back and down to ground level
        couch.castShadow = true;
        couch.receiveShadow = true;
        scene.add(couch);

        // Floor Standing Speaker (corner)
        const speaker = new THREE.Group();

        const speakerBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 2.5, 0.8),
            new THREE.MeshStandardMaterial({ color: 0x222222 })
        );
        speakerBox.position.y = 1.25;
        speaker.add(speakerBox);

        // Speaker drivers
        const woofer = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        woofer.position.set(0, 0.8, 0.41);
        woofer.rotation.x = Math.PI / 2;
        speaker.add(woofer);

        const tweeter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
        );
        tweeter.position.set(0, 1.6, 0.41);
        tweeter.rotation.x = Math.PI / 2;
        speaker.add(tweeter);

        speaker.position.set(12, 0, 12);
        speaker.rotation.y = -Math.PI * 0.75; // Face inward toward center of room
        speaker.castShadow = true;
        scene.add(speaker);

        // Store speaker reference globally for interaction
        window.speakerObject = speaker;

        console.log('Room elements added successfully!');


        // Character creation - Josh Chou
        const characters = [];

        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);

            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);

            // Name label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);

            group.position.set(x, 0, z);
            group.userData = {
                name,
                role,
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };

            characters.push(group);
            return group;
        }

        // Create Josh Chou character
        const josh = createCharacter('Josh Chou', 'Software Engineer & Developer', 3, -5, 0x4169e1, {
            hairColor: 0x3d3d3d,
            personality: 'passionate and innovative',
            quirk: 'always optimizing code and processes'
        });

        scene.add(josh);

        // Collision detection system
        const collisionObjects = [];

        // Function to add collision object
        function addCollisionObject(object, radius = 1) {
            collisionObjects.push({
                object: object,
                radius: radius,
                position: object.position.clone()
            });
        }

        // Function to check collision
        function checkCollision(newPosition) {
            for (let collisionObj of collisionObjects) {
                const distance = newPosition.distanceTo(collisionObj.position);
                if (distance < collisionObj.radius + 0.5) { // 0.5 is player radius
                    return true; // Collision detected
                }
            }
            return false;
        }

        // Add collision objects for furniture and characters
        function setupCollisions() {
            // Add main desk collision
            const mainDesk = scene.getObjectByName('mainDesk') || scene.children.find(child =>
                child.type === 'Group' && child.children.some(c => c.geometry && c.geometry.type === 'BoxGeometry')
            );
            if (mainDesk) {
                addCollisionObject(mainDesk, 2);
            }

            // Add character collisions
            characters.forEach(character => {
                addCollisionObject(character, 0.8);
            });

            // Add plant pot collisions
            const plantPots = scene.children.filter(child =>
                child.geometry && child.geometry.type === 'CylinderGeometry' &&
                child.material && child.material.color && child.material.color.getHex() === 0x8b4513
            );
            plantPots.forEach(plant => {
                addCollisionObject(plant, 0.5);
            });

            // Add plant leaves (bushes) collisions
            const plantLeaves = scene.children.filter(child =>
                child.geometry && child.geometry.type === 'SphereGeometry' &&
                child.material && child.material.color && child.material.color.getHex() === 0x228b22
            );
            plantLeaves.forEach(leaves => {
                addCollisionObject(leaves, 0.8);
            });

            // Add whiteboard collision
            const whiteboard = scene.children.find(child =>
                child.geometry && child.geometry.type === 'BoxGeometry' &&
                child.position.z === -19.8
            );
            if (whiteboard) {
                addCollisionObject(whiteboard, 2);
            }

            // Add bookshelf collision
            if (window.bookshelfObject) {
                addCollisionObject(window.bookshelfObject, 2);
            }

            // Add couch collision
            const couch = scene.children.find(child =>
                child.type === 'Group' && child.position.x === 0 && child.position.z === 3.5
            );
            if (couch) {
                addCollisionObject(couch, 2.5);
            }

            // Add TV collision
            if (window.tvObject) {
                addCollisionObject(window.tvObject, 2);
            }

            // Add speaker collision
            if (window.speakerObject) {
                addCollisionObject(window.speakerObject, 1);
            }

            // Add coffee table collision
            const coffeeTable = scene.children.find(child =>
                child.type === 'Group' && child.position.x === 0 && child.position.z === 1.5
            );
            if (coffeeTable) {
                addCollisionObject(coffeeTable, 1.5);
            }

            // Add area rug collision (softer collision, smaller radius)
            const areaRug = scene.children.find(child =>
                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                child.position.y === 0.01 && child.rotation.x === -Math.PI / 2
            );
            if (areaRug) {
                addCollisionObject(areaRug, 2);
            }

            // Add wall collisions to prevent walking through walls
            // Back wall
            const backWall = scene.children.find(child =>
                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                Math.abs(child.position.z - 15) < 0.1
            );
            if (backWall) {
                addCollisionObject(backWall, 1);
            }

            // Front wall
            const frontWall = scene.children.find(child =>
                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                Math.abs(child.position.z + 15) < 0.1
            );
            if (frontWall) {
                addCollisionObject(frontWall, 1);
            }

            // Left wall
            const leftWall = scene.children.find(child =>
                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                Math.abs(child.position.x + 15) < 0.1
            );
            if (leftWall) {
                addCollisionObject(leftWall, 1);
            }

            // Right wall
            const rightWall = scene.children.find(child =>
                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                Math.abs(child.position.x - 15) < 0.1
            );
            if (rightWall) {
                addCollisionObject(rightWall, 1);
            }

            console.log(`Added ${collisionObjects.length} collision objects`);
        }

        // Custom question input removed - using predetermined questions only

        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 1.2),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            isJumping: false,
            jumpVelocity: 0,
            onGround: true,
            groundHeight: 1.6
        };

        const keys = {};

        document.addEventListener('keydown', (e) => {
            // Custom input removed - no need to check active element

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true; // Store original key for arrow keys

            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }

            // Open computer terminal with 'P' key when near desk
            if (e.key.toLowerCase() === 'c' && window.deskObject && dialogueBox.style.display !== 'block') {
                const deskDistance = player.position.distanceTo(window.deskObject.position);
                console.log('C key pressed! Distance:', deskDistance, 'Desk exists:', !!window.deskObject);
                if (deskDistance < 3) {
                    e.preventDefault();
                    console.log('Opening terminal...');
                    openComputerTerminal();
                }
            }

            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                // Only jump if on ground
                if (player.onGround) {
                    player.isJumping = true;
                    player.jumpVelocity = 0.3; // Initial jump velocity
                    player.onGround = false;
                }
            }

            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            // Custom input removed - no need to check active element

            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false; // Clear original key for arrow keys

            // Note: Jump physics handles completion automatically, no need for keyup handler
        });

        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            // Random events
            if (Math.random() < character.userData.tripChance && !character.userData.isDancing) {
                // Character trips!
                character.rotation.x = Math.PI / 4;
                character.position.y = 0.3;

                setTimeout(() => {
                    character.rotation.x = 0;
                    character.position.y = 0;
                }, 1000);

                character.userData.tripChance = 0;
                setTimeout(() => {
                    character.userData.tripChance = 0.001;
                }, 5000);
            }

            // Don't move if this character is in conversation or dancing
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    // Face the player
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }

            // Random dance party
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }

            character.userData.moveTimer -= deltaTime;

            if (character.userData.moveTimer <= 0) {
                // Set new random target
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );

                // Keep within bounds
                character.userData.targetPosition.x = Math.max(-13, Math.min(13, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-13, Math.min(13, character.userData.targetPosition.z));

                character.userData.moveTimer = 5 + Math.random() * 5;
            }

            // Move towards target
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();

            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));

                // Face movement direction
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;

                // Walking animation
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }

        // Dialogue system with recruitment-focused questions
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');

        let currentCharacter = null;
        let nearbyCharacter = null;

        function generateDialogueOptions(character) {
            // Priority questions (most important - shown first)
            const priorityQuestions = [
                {
                    question: "Tell me about yourself",
                    response: "I'm Josh Chou, a Computer Science and Entrepreneurship student at UW with a 3.8 GPA, graduating in June 2026. I'm passionate about building scalable systems and designing intuitive user experiences. Outside of work, I love spending time outdoors whether it's playing sports, backpacking or skipping rocks. I love  meeting new people, taking risks, and learning new things!",
                    priority: true
                },
                {
                    question: "What's your most impressive project?",
                    response: "My AWS real-time fraud detection system stands out - it processes 50 million AWS activity logs daily and reduced fraud detection time from 15-60 minutes to seconds, a 95% improvement. I built it using TypeScript, GraphQL, and event-driven architecture with Lambda, Kinesis, and SQS. The project earned me the AWS Spark Fair Award as the top-performing intern across all disciplines.",
                    priority: true
                },
                {
                    question: "What are your strongest programming languages?",
                    response: "My strongest languages are Java, Python, and TypeScript/JavaScript. I've used Java extensively in coursework, Python for machine learning projects and backend development, and TypeScript for building scalable web applications and during my internships at AWS. I'm also proficient in C/C++ for systems programming, having built a search engine and distributed key-value store.",
                    priority: true
                },
                {
                    question: "Tell me about a challenging problem you solved",
                    response: "At AWS, I faced the challenge of processing massive CloudTrail logs in real-time for fraud detection. The existing system had 15-60 minute delays. I designed an event-driven architecture using Lambda functions triggered by Kinesis streams, with SQS for reliable message queuing and SNS for instant alerts. The key was implementing exactly-once processing semantics and handling backpressure during traffic spikes.",
                    priority: true
                }
            ];

            // Additional questions (shown after priority ones)
            const additionalQuestions = [
                {
                    question: "Where do you see yourself in 5 years?",
                    response: "In 5 years, I see myself as a senior software engineer or tech lead at a company building impactful products at scale. I want to continue growing my expertise in distributed systems and machine learning while mentoring junior developers. My experience as a founding engineer and CTO has shown me I enjoy both the technical challenges and the strategic thinking involved in building products from the ground up."
                },
                {
                    question: "How do you approach learning new technologies?",
                    response: "I learn by building projects and solving real problems. When I wanted to learn computer vision, I built TestDrive.AI to automate driving test evaluations. For distributed systems, I implemented a Paxos-based key-value store. I also stay current through technical articles and podcasts, participate in hackathons like DubHacks where I won first place, and completed programs like Y Combinator's AI Startup School."
                },
                {
                    question: "What's your ideal work environment?",
                    response: "I thrive in collaborative environments where I can work on challenging technical problems with smart people. I enjoy having autonomy to architect solutions while also being able to collaborate closely with team members. My experience at startups has shown me I like faster paced environments where I can wear multiple hats."
                },
                {
                    question: "How do you work in a team?",
                    response: "I believe in clear communication and shared ownership. At Affable BPM, I collaborated closely with the founder on product strategy while leading technical implementations. I always advocate for my ideas but stay open to feedback. I also love to help and mentor others at any chance I get."
                },
                {
                    question: "What motivates you as a developer?",
                    response: "I'm motivated by solving complex problems that have real impact. Seeing my fraud detection system protect AWS customers from security threats, or knowing TestDrive.AI could improve road safety is incredibly fulfilling. I also love the continuous learning aspect of tech. Especially now with AI evolving at an insane pace, it is thrilling knowing that everyone is learning things together and that by staying up to date, I am at the cutting edge of technology."
                },
                {
                    question: "Walk me through your resume",
                    response: "I'm currently a CS student at UW graduating in June 2026 with a 3.8 GPA. I've had two internships at AWS - most recently as an SDE intern where I built a fraud detection system that won the Spark Fair Award. I'm also a founding engineer at Affable BPM and CTO of OdysseyHydration. My notable projects include TestDrive.AI for automated driving tests, a distributed key-value store, and WakeBox which won first place at DubHacks with 12,000+ competitors. My full resume can be found in the contact tab."
                },
                {
                    question: "What's your educational background?",
                    response: "I'm pursuing a Bachelor of Science in Computer Science at the University of Washington, with a minor in Neural Computation and Entrepreneurship, graduating in June 2026. I maintain a 3.8 GPA and have taken courses in Data Structures, Distributed Systems, Machine Learning, and Advanced Algorithms. I was also selected for Y Combinator's AI Startup School as one of the top 2000 CS students globally specializing in AI."
                },
                {
                    question: "How do you handle pressure and deadlines?",
                    response: "I thrive under pressure and use it as motivation. During my AWS internship, I had tight deadlines to deliver the fraud detection system, so I broke it into manageable milestones and communicated progress regularly. At hackathons like DubHacks, I work well in time-constrained environments. I prioritize tasks, focus on MVP functionality first, then iterate. Good planning and clear communication with stakeholders are key to managing pressure effectively."
                },
                {
                    question: "What's your biggest weakness?",
                    response: "I sometimes spend too much time perfecting code and user experiences when I should ship an MVP first. I've learned to balance code quality with delivery speed by setting clear definitions of 'done' and iterating based on feedback. Now I focus on building something that works well, then refining it based on real usage patterns."
                },
                {
                    question: "Tell me about your leadership experience",
                    response: "As CTO of OdysseyHydration, I lead technical strategy and development decisions. At Affable BPM, I guide the technical roadmap and mentor other developers. During my AWS internship, I took ownership of the fraud detection project from conception to deployment. In high schoo, I assumed leadership roles in a number of clubs including starting a couple of my own. I strongly believe in being the change you want to see."
                },
                {
                    question: "What do you do outside of programming?",
                    response: "Outside of programming, I enjoy staying active and exploring new places. I like hiking and trying out different restaurants. I'm also interested in entrepreneurship and product strategy, which ties into my technical work. I find that stepping away from code gives me fresh perspectives on problem-solving and helps me come back with new ideas."
                },
                {
                    question: "How do you approach debugging complex issues?",
                    response: "I approach debugging systematically. First, I reproduce the issue consistently, then I isolate variables to narrow down the root cause. I use logging strategically, examine stack traces, and leverage debugging tools like Chrome DevTools or profilers. I also strongly believe that documentation is key. I write down what I've tried so I don't repeat steps, and I share findings with the team for knowledge sharing. When I participated in competitive robotics, I would always volunteer to take on the documentation for the team (filling out engineering journals)."
                }
            ];

            return { priorityQuestions, additionalQuestions };
        }

        function displayQuestionOptions(character, allQuestions) {
            const dialogueOptions = document.getElementById('dialogue-options');
            dialogueOptions.innerHTML = '';

            // Get currently shown questions
            let currentlyShown = character.userData.shownQuestions || [];

            // If we have less than 4 shown questions, we need to add more
            if (currentlyShown.length < 4) {
                const askedQuestions = character.userData.conversations.map(conv => conv.user);
                const availableToShow = character.userData.availableQuestions.filter(q =>
                    !askedQuestions.includes(q.question) &&
                    !currentlyShown.includes(q.question)
                );

                // Add priority questions first, then random additional ones
                const priorityToShow = availableToShow.filter(q => q.priority);
                const additionalToShow = availableToShow.filter(q => !q.priority);

                // Fill up to 4 questions, priority first
                while (currentlyShown.length < 4 && (priorityToShow.length > 0 || additionalToShow.length > 0)) {
                    if (priorityToShow.length > 0) {
                        currentlyShown.push(priorityToShow.shift().question);
                    } else if (additionalToShow.length > 0) {
                        // Random selection from additional questions
                        const randomIndex = Math.floor(Math.random() * additionalToShow.length);
                        currentlyShown.push(additionalToShow.splice(randomIndex, 1)[0].question);
                    }
                }

                character.userData.shownQuestions = currentlyShown;
            }

            // Display the 4 current questions
            currentlyShown.forEach(questionText => {
                const questionData = allQuestions.find(q => q.question === questionText);
                if (questionData) {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'dialogue-option';
                    optionDiv.textContent = questionData.question;
                    optionDiv.onclick = () => selectQuestionAndRotate(questionData, character, allQuestions);
                    dialogueOptions.appendChild(optionDiv);
                }
            });

            // If no questions are available, show reset option
            if (currentlyShown.length === 0) {
                const resetDiv = document.createElement('div');
                resetDiv.className = 'dialogue-option';
                resetDiv.textContent = "Ask me more questions (reset conversation)";
                resetDiv.onclick = () => {
                    character.userData.conversations = [];
                    character.userData.shownQuestions = [];
                    openDialogue(character);
                };
                dialogueOptions.appendChild(resetDiv);
            }
        }

        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name}`;


            const greetings = [
                `Hi! I'm ${character.userData.name}. Thanks for checking out my interactive portfolio! Feel free to ask me anything about my background and experience.`,
                `Hello there! Welcome to my virtual office. I'm ${character.userData.name}, and I'd love to tell you about my journey as a developer.`,
                `Great to meet you! I'm ${character.userData.name}. This is a fun way to learn about my skills and experience - ask me anything!`,
                `Hey! I'm ${character.userData.name}. I built this interactive portfolio to showcase my work in a unique way. What would you like to know?`
            ];

            if (character.userData.conversations.length === 0) {
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
            } else {
                // Show last exchange
                const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
            }

            // Initialize question tracking if not exists
            if (!character.userData.shownQuestions) {
                character.userData.shownQuestions = [];
                character.userData.availableQuestions = [];
            }

            // Generate initial question pool
            const { priorityQuestions, additionalQuestions } = generateDialogueOptions(character);
            const allQuestions = [...priorityQuestions, ...additionalQuestions];

            // Initialize available questions pool if empty
            if (character.userData.availableQuestions.length === 0) {
                character.userData.availableQuestions = [...allQuestions];
            }

            // Display initial 4 questions (priority first)
            displayQuestionOptions(character, allQuestions);

            // No custom input needed - only predetermined questions
        }

        async function selectQuestionAndRotate(questionData, character, allQuestions) {
            if (!character) return;

            // Show selected question
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${questionData.question}</p>`;
            dialogueContent.innerHTML += `<p><strong>${character.userData.name}:</strong> <span class="loading"></span></p>`;

            // Scroll to bottom of dialogue
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Disable options during loading
            const dialogueOptions = document.getElementById('dialogue-options');
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';

            // Simulate thinking time
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Update conversation
            character.userData.conversations.push({
                user: questionData.question,
                response: questionData.response
            });

            // Update display with predetermined response
            dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                '<span class="loading"></span>',
                questionData.response
            );

            // Scroll to bottom
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Random dialogue events
            if (Math.random() < 0.2) {
                createFloatingText('üí°', character.position);
            }

            // Then rotate the question out and bring in a new one
            rotateQuestion(questionData.question, character, allQuestions);
        }

        async function selectOption(question, response) {
            if (!currentCharacter) return;

            // Show selected question
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${question}</p>`;
            dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;

            // Scroll to bottom of dialogue
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Disable options during loading
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';

            // Simulate thinking time
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Update conversation
            currentCharacter.userData.conversations.push({
                user: question,
                response: response
            });

            // Update display with predetermined response
            dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                '<span class="loading"></span>',
                response
            );

            // Scroll to bottom
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Random dialogue events
            if (Math.random() < 0.2) {
                createFloatingText('üí°', currentCharacter.position);
            }

            // Re-enable options - rotation will be handled after this
            const askedQuestions = currentCharacter.userData.conversations.map(conv => conv.user);
            const availableQuestions = allQuestions.filter(data => !askedQuestions.includes(data.question));

            dialogueOptions.innerHTML = '';

            if (availableQuestions.length > 0) {
                availableQuestions.forEach(data => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'dialogue-option';
                    optionDiv.textContent = data.question;
                    optionDiv.onclick = () => selectOption(data.question, data.response);
                    dialogueOptions.appendChild(optionDiv);
                });
            } else {
                // Show a reset option if all questions have been asked
                const resetDiv = document.createElement('div');
                resetDiv.className = 'dialogue-option';
                resetDiv.textContent = "Ask me more questions (reset conversation)";
                resetDiv.onclick = () => {
                    currentCharacter.userData.conversations = [];
                    openDialogue(currentCharacter);
                };
                dialogueOptions.appendChild(resetDiv);
            }

            // Re-enable options
            dialogueOptions.style.pointerEvents = 'auto';
            dialogueOptions.style.opacity = '1';
        }

        function rotateQuestion(answeredQuestion, character, allQuestions) {
            // Remove the answered question from currently shown
            character.userData.shownQuestions = character.userData.shownQuestions.filter(q => q !== answeredQuestion);

            // Find a new question to add
            const askedQuestions = character.userData.conversations.map(conv => conv.user);
            const availableToShow = character.userData.availableQuestions.filter(q =>
                !askedQuestions.includes(q.question) &&
                !character.userData.shownQuestions.includes(q.question)
            );

            // Add a new question if available
            if (availableToShow.length > 0) {
                // Prioritize unasked priority questions, then random additional ones
                const priorityToShow = availableToShow.filter(q => q.priority);
                if (priorityToShow.length > 0) {
                    character.userData.shownQuestions.push(priorityToShow[0].question);
                } else {
                    // Random selection from additional questions
                    const randomIndex = Math.floor(Math.random() * availableToShow.length);
                    character.userData.shownQuestions.push(availableToShow[randomIndex].question);
                }
            }

            // Refresh the displayed options and re-enable them
            displayQuestionOptions(character, allQuestions);

            // Ensure options are re-enabled after rotation
            const dialogueOptions = document.getElementById('dialogue-options');
            dialogueOptions.style.pointerEvents = 'auto';
            dialogueOptions.style.opacity = '1';
        }

        // Predetermined responses are now handled in the generateDialogueOptions function

        // Close dialogue with Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close computer terminal if open
                const terminal = document.getElementById('computer-terminal');
                if (terminal.style.display === 'block') {
                    closeComputerTerminal();
                    return;
                }

                dialogueBox.style.display = 'none';
                currentCharacter = null;
            }
        });

        // Custom question handlers removed completely

        // Contact modal functionality
        const contactTab = document.getElementById('contact-tab');
        const contactModal = document.getElementById('contact-modal');
        const closeContact = document.getElementById('close-contact');

        contactTab.addEventListener('click', () => {
            contactModal.style.display = 'flex';
        });

        closeContact.addEventListener('click', () => {
            contactModal.style.display = 'none';
        });

        // Close modal when clicking outside
        contactModal.addEventListener('click', (e) => {
            if (e.target === contactModal) {
                contactModal.style.display = 'none';
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                contactModal.style.display = 'none';
                dialogueBox.style.display = 'none';
                currentCharacter = null;
            }
        });

        // Social icons hover effects
        const socialIcons = document.querySelectorAll('.social-icon');
        socialIcons.forEach(icon => {
            icon.addEventListener('mouseenter', () => {
                icon.style.transform = 'translateY(-3px) scale(1.1)';
            });

            icon.addEventListener('mouseleave', () => {
                icon.style.transform = 'translateY(0) scale(1)';
            });
        });

        // Animation loop
        let lastTime = 0;
        let animationStarted = false;
        let nearbyPainting = null;
        let tooltipTimeout = null;

        // Painting tooltip data
        const paintingTooltips = {
            'painting1': {
                title: 'Professional Photo 1',
                description: 'My first time winning prize money from pickleball'
            },
            'painting2': {
                title: 'Professional Photo 2',
                description: 'Organizing my rock collection'
            },
            'painting3': {
                title: 'Professional Photo 3',
                description: 'Me and my brother at YC AI Startup school'
            },
            'painting4': {
                title: 'Professional Photo 4',
                description: 'Me!'
            },
            'painting5': {
                title: 'Professional Photo 5',
                description: 'Summiting a mountain'
            },
            'painting6': {
                title: 'Professional Photo 6',
                description: 'Playing my favorite game, mahjong'
            },
            'painting7': {
                title: 'Professional Photo 7',
                description: 'Playing my other favorite game, catan'
            }
        };

        // Function to show painting tooltip
        function showPaintingTooltip(paintingId, worldPosition) {
            const tooltip = document.getElementById('painting-tooltip');
            const title = document.getElementById('tooltip-title');
            const description = document.getElementById('tooltip-description');

            if (paintingTooltips[paintingId]) {
                title.textContent = paintingTooltips[paintingId].title;
                description.textContent = paintingTooltips[paintingId].description;

                // Position tooltip near the top of the screen
                tooltip.style.left = '50%';
                tooltip.style.top = '20px';
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.style.display = 'block';

                nearbyPainting = paintingId;
            }
        }

        // Function to hide painting tooltip
        function hidePaintingTooltip() {
            const tooltip = document.getElementById('painting-tooltip');
            tooltip.style.display = 'none';
            nearbyPainting = null;
        }

        function animate(currentTime) {
            requestAnimationFrame(animate);

            if (!animationStarted) {
                console.log('Animation loop started');
                animationStarted = true;
            }

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update player movement (only if dialogue is not open)
            player.velocity.set(0, 0, 0);

            if (dialogueBox.style.display !== 'block') {
                if (keys['w']) player.velocity.z = player.speed;
                if (keys['s']) player.velocity.z = -player.speed;
                if (keys['a']) player.velocity.x = -player.speed;
                if (keys['d']) player.velocity.x = player.speed;
            }

            // Arrow key camera controls (left/right only, disabled during dialogue)
            const lookSpeed = 0.05;
            if (dialogueBox.style.display !== 'block') {
                if (keys['ArrowLeft']) {
                    mouseX += lookSpeed;
                }
                if (keys['ArrowRight']) {
                    mouseX -= lookSpeed;
                }
            }

            // Update camera rotation based on arrow key inputs (horizontal only, disabled during dialogue)
            if (dialogueBox.style.display !== 'block') {
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
            }

            // Apply movement in camera direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();

            // Calculate new position with collision detection
            const newPosition = player.position.clone();
            const forwardMovement = forward.clone().multiplyScalar(player.velocity.z);
            const rightMovement = right.clone().multiplyScalar(player.velocity.x);

            // Try forward movement first
            if (player.velocity.z !== 0) {
                const testPosition = newPosition.clone().add(forwardMovement);
                if (!checkCollision(testPosition)) {
                    newPosition.add(forwardMovement);
                }
            }

            // Try right movement second
            if (player.velocity.x !== 0) {
                const testPosition = newPosition.clone().add(rightMovement);
                if (!checkCollision(testPosition)) {
                    newPosition.add(rightMovement);
                }
            }

            // Update player position
            player.position.copy(newPosition);

            // Keep player in bounds
            player.position.x = Math.max(-13, Math.min(13, player.position.x));
            player.position.z = Math.max(-13, Math.min(13, player.position.z));

            // Apply jump physics
            if (player.isJumping) {
                player.jumpVelocity -= 0.01; // Gravity
                player.position.y += player.jumpVelocity;

                if (player.jumpVelocity < 0 && player.position.y <= player.groundHeight) {
                    player.position.y = player.groundHeight;
                    player.jumpVelocity = 0;
                    player.isJumping = false;
                    player.onGround = true;
                }
            }

            // Update camera position to follow player
            if (dialogueBox.style.display !== 'block') {
                camera.position.copy(player.position);
                camera.rotation.y = mouseX;
                camera.rotation.x = 0;
                camera.rotation.z = 0;
            }

            // Update character movement
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);

                // Dancing animation
                if (character.userData.isDancing) {
                    character.rotation.y += 0.1;
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.3;

                    // Arm waving
                    character.userData.leftArm.rotation.z = Math.sin(Date.now() * 0.01) * 0.5 + Math.PI / 8;
                    character.userData.rightArm.rotation.z = -Math.sin(Date.now() * 0.01) * 0.5 - Math.PI / 8;
                }
            });

            // Check for nearby characters
            nearbyCharacter = null;
            let minDistance = Infinity;

            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 3 && distance < minDistance) {
                    minDistance = distance;
                    nearbyCharacter = character;
                }
            });

            // Show/hide interaction prompt (only when dialogue is not open)
            if (nearbyCharacter && !currentCharacter) {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to Talk`;
            } else {
                interactionPrompt.style.display = 'none';
            }

            // Check for nearby paintings
            let closestPainting = null;
            let closestPaintingDistance = Infinity;

            paintings.forEach(painting => {
                const distance = player.position.distanceTo(painting.painting.position);
                if (distance < 4 && distance < closestPaintingDistance) {
                    closestPaintingDistance = distance;
                    closestPainting = painting;
                }
            });

            // Show/hide painting tooltip
            if (closestPainting && closestPaintingDistance < 4) {
                showPaintingTooltip(closestPainting.data.id, closestPainting.painting.position);
            } else {
                hidePaintingTooltip();
            }

            // Check for speaker proximity
            if (window.speakerObject) {
                const speakerDistance = player.position.distanceTo(window.speakerObject.position);
                const speakerTooltip = document.getElementById('speaker-tooltip');

                if (speakerDistance < 4) {
                    // Show speaker tooltip
                    speakerTooltip.style.display = 'block';

                    // Position tooltip near speaker
                    const speakerTopPos = window.speakerObject.position.clone();
                    speakerTopPos.y += 2.5; // Add speaker height to get the top
                    speakerTopPos.project(camera);

                    const x = (speakerTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (speakerTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the speaker with some margin
                    speakerTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    speakerTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    speakerTooltip.style.display = 'none';
                }
            }

            // Check for TV proximity
            if (window.tvObject) {
                const tvDistance = player.position.distanceTo(window.tvObject.position);
                const tvTooltip = document.getElementById('tv-tooltip');

                if (tvDistance < 4) {
                    // Show TV tooltip
                    tvTooltip.style.display = 'block';

                    // Position tooltip above TV (using the top of the TV)
                    const tvTopPos = window.tvObject.position.clone();
                    tvTopPos.y += 3; // Add TV height to get the top
                    tvTopPos.project(camera);

                    const x = (tvTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (tvTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the TV with some margin
                    tvTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    tvTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    tvTooltip.style.display = 'none';
                }
            }

            // Check for bookshelf proximity
            if (window.bookshelfObject) {
                const bookshelfDistance = player.position.distanceTo(window.bookshelfObject.position);
                const bookshelfTooltip = document.getElementById('bookshelf-tooltip');

                if (bookshelfDistance < 4) {
                    // Show bookshelf tooltip
                    bookshelfTooltip.style.display = 'block';

                    // Position tooltip above bookshelf (using the top of the bookshelf)
                    const bookshelfTopPos = window.bookshelfObject.position.clone();
                    bookshelfTopPos.y += 2.5; // Add bookshelf height to get the top
                    bookshelfTopPos.project(camera);

                    const x = (bookshelfTopPos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (bookshelfTopPos.y * -0.5 + 0.5) * window.innerHeight;

                    // Position tooltip above the bookshelf with some margin
                    bookshelfTooltip.style.left = Math.min(Math.max(x - 150, 20), window.innerWidth - 320) + 'px';
                    bookshelfTooltip.style.top = Math.max(y - 150, 20) + 'px';
                } else {
                    bookshelfTooltip.style.display = 'none';
                }
            }

            // Check for computer/desk proximity
            if (window.deskObject) {
                const deskDistance = player.position.distanceTo(window.deskObject.position);

                if (deskDistance < 3) {
                    // Show computer interaction prompt
                    if (nearbyCharacter === null && !currentCharacter) {
                        interactionPrompt.style.display = 'block';
                        interactionPrompt.textContent = `Press C to Access Computer (Projects)`;
                    }
                } else {
                    // Only hide prompt if it's showing computer message
                    if (interactionPrompt.textContent.includes('Computer')) {
                        interactionPrompt.style.display = 'none';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Arrow key look (horizontal only)
        let mouseX = 0;

        // Computer terminal functions
        function openComputerTerminal() {
            const terminal = document.getElementById('computer-terminal');
            terminal.style.display = 'block';
            // Disable game controls when terminal is open
            document.body.style.pointerEvents = 'auto';
        }

        function closeComputerTerminal() {
            const terminal = document.getElementById('computer-terminal');
            terminal.style.display = 'none';
            // Re-enable game controls
            document.body.style.pointerEvents = 'none';
            document.querySelector('canvas').style.pointerEvents = 'auto';
        }

        // Make functions globally available
        window.openComputerTerminal = openComputerTerminal;
        window.closeComputerTerminal = closeComputerTerminal;

        console.log('Starting animation...');

        // Setup collision detection
        setupCollisions();

        animate(0);

        // Animation loop
    </script>
</body>
</html>